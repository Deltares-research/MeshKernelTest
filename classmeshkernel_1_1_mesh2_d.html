<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeshKernel: meshkernel::Mesh2D Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MeshKernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemeshkernel.html">meshkernel</a></li><li class="navelem"><a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classmeshkernel_1_1_mesh2_d-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">meshkernel::Mesh2D Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class derived from <a class="el" href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2...">Mesh</a>, which describes unstructures 2d meshes.  
 <a href="classmeshkernel_1_1_mesh2_d.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_mesh2_d_8hpp_source.html">Mesh2D.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for meshkernel::Mesh2D:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmeshkernel_1_1_mesh2_d.png" usemap="#meshkernel::Mesh2D_map" alt=""/>
  <map id="meshkernel::Mesh2D_map" name="meshkernel::Mesh2D_map">
<area href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2..." alt="meshkernel::Mesh" shape="rect" coords="0,0,129,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a41e7c8bf5e92fec3f46ba18204e8cc6e"><td class="memItemLeft" align="right" valign="top"><a id="a41e7c8bf5e92fec3f46ba18204e8cc6e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a41e7c8bf5e92fec3f46ba18204e8cc6e">DeleteMeshOptions</a> { <b>AllNodesInside</b> = 0, 
<b>FacesWithIncludedCircumcenters</b> = 1, 
<b>FacesCompletelyIncluded</b> = 2
 }</td></tr>
<tr class="memdesc:a41e7c8bf5e92fec3f46ba18204e8cc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator describing the different options to delete a mesh. <br /></td></tr>
<tr class="separator:a41e7c8bf5e92fec3f46ba18204e8cc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17db40a7b9ea9151e51231c4af416d47"><td class="memItemLeft" align="right" valign="top"><a id="a17db40a7b9ea9151e51231c4af416d47"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a17db40a7b9ea9151e51231c4af416d47">NodeTypes</a> { <br />
&#160;&#160;<b>internalNode</b>, 
<b>onRing</b>, 
<b>cornerNode</b>, 
<b>hangingNode</b>, 
<br />
&#160;&#160;<b>other</b>
<br />
 }</td></tr>
<tr class="memdesc:a17db40a7b9ea9151e51231c4af416d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator describing the different node types. <br /></td></tr>
<tr class="separator:a17db40a7b9ea9151e51231c4af416d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:a556f63787abcf8335e8f5e5a27580984 inherit pub_types_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a556f63787abcf8335e8f5e5a27580984"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a556f63787abcf8335e8f5e5a27580984">MeshTypes</a> { <b>Mesh1D</b>, 
<b>Mesh2D</b>
 }</td></tr>
<tr class="memdesc:a556f63787abcf8335e8f5e5a27580984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator describing the different mesh types. <br /></td></tr>
<tr class="separator:a556f63787abcf8335e8f5e5a27580984 inherit pub_types_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9194a3e8f0ac27124390ed34a8f29ef8"><td class="memItemLeft" align="right" valign="top"><a id="a9194a3e8f0ac27124390ed34a8f29ef8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a9194a3e8f0ac27124390ed34a8f29ef8">Mesh2D</a> ()=default</td></tr>
<tr class="memdesc:a9194a3e8f0ac27124390ed34a8f29ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a9194a3e8f0ac27124390ed34a8f29ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac667a2395d4b205d7c4be2536bc301eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ac667a2395d4b205d7c4be2536bc301eb">Mesh2D</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a7fda31b0d2488c53f4b00c5d2e764fb7">Edge</a> &gt; &amp;edges, const std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:ac667a2395d4b205d7c4be2536bc301eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh2d starting from the edges and nodes.  <a href="classmeshkernel_1_1_mesh2_d.html#ac667a2395d4b205d7c4be2536bc301eb">More...</a><br /></td></tr>
<tr class="separator:ac667a2395d4b205d7c4be2536bc301eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba8740c34f7b23d18e022c04b15f477"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a4ba8740c34f7b23d18e022c04b15f477">Mesh2D</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a7fda31b0d2488c53f4b00c5d2e764fb7">Edge</a> &gt; &amp;edges, const std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, const std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;faceNodes, const std::vector&lt; size_t &gt; &amp;numFaceNodes, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:a4ba8740c34f7b23d18e022c04b15f477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh2d from face nodes and num face nodes.  <a href="classmeshkernel_1_1_mesh2_d.html#a4ba8740c34f7b23d18e022c04b15f477">More...</a><br /></td></tr>
<tr class="separator:a4ba8740c34f7b23d18e022c04b15f477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae466a7ef61c51eb720f50d31ed94ca1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aae466a7ef61c51eb720f50d31ed94ca1">Mesh2D</a> (const std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:aae466a7ef61c51eb720f50d31ed94ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create triangular grid from nodes (triangulatesamplestonetwork)  <a href="classmeshkernel_1_1_mesh2_d.html#aae466a7ef61c51eb720f50d31ed94ca1">More...</a><br /></td></tr>
<tr class="separator:aae466a7ef61c51eb720f50d31ed94ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf046d573135e33e8074b18b6d456008"><td class="memItemLeft" align="right" valign="top"><a id="adf046d573135e33e8074b18b6d456008"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#adf046d573135e33e8074b18b6d456008">Administrate</a> ()</td></tr>
<tr class="memdesc:adf046d573135e33e8074b18b6d456008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform mesh administration. <br /></td></tr>
<tr class="separator:adf046d573135e33e8074b18b6d456008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf625bb91c465cf93bfed19ce43dad50"><td class="memItemLeft" align="right" valign="top"><a id="aaf625bb91c465cf93bfed19ce43dad50"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aaf625bb91c465cf93bfed19ce43dad50">ComputeCircumcentersMassCentersAndFaceAreas</a> (bool computeMassCenters=false)</td></tr>
<tr class="memdesc:aaf625bb91c465cf93bfed19ce43dad50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute face circumcenters. <br /></td></tr>
<tr class="separator:aaf625bb91c465cf93bfed19ce43dad50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b94a7acb30a64061a8767efec60811b"><td class="memItemLeft" align="right" valign="top"><a id="a5b94a7acb30a64061a8767efec60811b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a5b94a7acb30a64061a8767efec60811b">FindFaces</a> ()</td></tr>
<tr class="memdesc:a5b94a7acb30a64061a8767efec60811b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find faces: constructs the m_facesNodes mapping, face mass centers and areas (findcells) <br /></td></tr>
<tr class="separator:a5b94a7acb30a64061a8767efec60811b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e874419b2e05ab89e9000f16f3e905b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a9e874419b2e05ab89e9000f16f3e905b">OffsetSphericalCoordinates</a> (double minx, double miny)</td></tr>
<tr class="memdesc:a9e874419b2e05ab89e9000f16f3e905b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset the x coordinates if m_projection is spherical.  <a href="classmeshkernel_1_1_mesh2_d.html#a9e874419b2e05ab89e9000f16f3e905b">More...</a><br /></td></tr>
<tr class="separator:a9e874419b2e05ab89e9000f16f3e905b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821f4925cc54788fc2637dd58a43d70b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a821f4925cc54788fc2637dd58a43d70b">ComputeFaceClosedPolygonWithLocalMappings</a> (size_t faceIndex, std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygonNodesCache, std::vector&lt; size_t &gt; &amp;localNodeIndicesCache, std::vector&lt; size_t &gt; &amp;globalEdgeIndicesCache) const</td></tr>
<tr class="memdesc:a821f4925cc54788fc2637dd58a43d70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a face create a closed polygon and fill local mapping caches (get_cellpolygon)  <a href="classmeshkernel_1_1_mesh2_d.html#a821f4925cc54788fc2637dd58a43d70b">More...</a><br /></td></tr>
<tr class="separator:a821f4925cc54788fc2637dd58a43d70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a95c66b7653e2d9f2dffee78bc2cdbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a1a95c66b7653e2d9f2dffee78bc2cdbd">ComputeFaceClosedPolygon</a> (size_t faceIndex, std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygonNodesCache) const</td></tr>
<tr class="memdesc:a1a95c66b7653e2d9f2dffee78bc2cdbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a face create a closed polygon.  <a href="classmeshkernel_1_1_mesh2_d.html#a1a95c66b7653e2d9f2dffee78bc2cdbd">More...</a><br /></td></tr>
<tr class="separator:a1a95c66b7653e2d9f2dffee78bc2cdbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee615054d70e2fb2879d6d6b730288ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmeshkernel_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aee615054d70e2fb2879d6d6b730288ab">ComputeFaceCircumenter</a> (std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygon, const std::vector&lt; size_t &gt; &amp;edgesNumFaces) const</td></tr>
<tr class="memdesc:aee615054d70e2fb2879d6d6b730288ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a closed polygon, compute the circumcenter of a face (getcircumcenter)  <a href="classmeshkernel_1_1_mesh2_d.html#aee615054d70e2fb2879d6d6b730288ab">More...</a><br /></td></tr>
<tr class="separator:aee615054d70e2fb2879d6d6b730288ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6575301bc3c4c17e3a76c5efca4ad5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aea6575301bc3c4c17e3a76c5efca4ad5">GetObtuseTrianglesCenters</a> ()</td></tr>
<tr class="memdesc:aea6575301bc3c4c17e3a76c5efca4ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mass centers of obtuse triangles.  <a href="classmeshkernel_1_1_mesh2_d.html#aea6575301bc3c4c17e3a76c5efca4ad5">More...</a><br /></td></tr>
<tr class="separator:aea6575301bc3c4c17e3a76c5efca4ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a094e46fb97f0e00772213b38922a3a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a5a094e46fb97f0e00772213b38922a3a">GetEdgesCrossingSmallFlowEdges</a> (double smallFlowEdgesThreshold)</td></tr>
<tr class="memdesc:a5a094e46fb97f0e00772213b38922a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the edges crossing the small flow edges.  <a href="classmeshkernel_1_1_mesh2_d.html#a5a094e46fb97f0e00772213b38922a3a">More...</a><br /></td></tr>
<tr class="separator:a5a094e46fb97f0e00772213b38922a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbb0f354d3087a90a41934defe7b0a9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aabbb0f354d3087a90a41934defe7b0a9">GetFlowEdgesCenters</a> (const std::vector&lt; size_t &gt; &amp;edges) const</td></tr>
<tr class="memdesc:aabbb0f354d3087a90a41934defe7b0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the flow edges centers from the crossing edges.  <a href="classmeshkernel_1_1_mesh2_d.html#aabbb0f354d3087a90a41934defe7b0a9">More...</a><br /></td></tr>
<tr class="separator:aabbb0f354d3087a90a41934defe7b0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6855534ffcff0ca5ac4ce4e1bc4ca229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a6855534ffcff0ca5ac4ce4e1bc4ca229">DeleteSmallFlowEdges</a> (double smallFlowEdgesThreshold)</td></tr>
<tr class="memdesc:a6855534ffcff0ca5ac4ce4e1bc4ca229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes small flow edges (removesmallflowlinks, part 1)  <a href="classmeshkernel_1_1_mesh2_d.html#a6855534ffcff0ca5ac4ce4e1bc4ca229">More...</a><br /></td></tr>
<tr class="separator:a6855534ffcff0ca5ac4ce4e1bc4ca229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03d80377cafe9fdfb22545423fb8fa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#af03d80377cafe9fdfb22545423fb8fa6">DeleteSmallTrianglesAtBoundaries</a> (double minFractionalAreaTriangles)</td></tr>
<tr class="memdesc:af03d80377cafe9fdfb22545423fb8fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes small triangles at the boundaries (removesmallflowlinks, part 2)  <a href="classmeshkernel_1_1_mesh2_d.html#af03d80377cafe9fdfb22545423fb8fa6">More...</a><br /></td></tr>
<tr class="separator:af03d80377cafe9fdfb22545423fb8fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ba61b67bf1c9b93d8f37124935545b"><td class="memItemLeft" align="right" valign="top"><a id="a43ba61b67bf1c9b93d8f37124935545b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a43ba61b67bf1c9b93d8f37124935545b">ComputeNodeNeighbours</a> ()</td></tr>
<tr class="memdesc:a43ba61b67bf1c9b93d8f37124935545b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes m_nodesNodes, see class members. <br /></td></tr>
<tr class="separator:a43ba61b67bf1c9b93d8f37124935545b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa6bfaadd219f15bbb7b45ee696a256"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#afaa6bfaadd219f15bbb7b45ee696a256">GetOrthogonality</a> ()</td></tr>
<tr class="memdesc:afaa6bfaadd219f15bbb7b45ee696a256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the orthogonality values, the inner product of edges and segments connecting the face circumcenters.  <a href="classmeshkernel_1_1_mesh2_d.html#afaa6bfaadd219f15bbb7b45ee696a256">More...</a><br /></td></tr>
<tr class="separator:afaa6bfaadd219f15bbb7b45ee696a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee516031de33d12a21a5d0aae1007162"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aee516031de33d12a21a5d0aae1007162">GetSmoothness</a> ()</td></tr>
<tr class="memdesc:aee516031de33d12a21a5d0aae1007162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the smoothness values, ratios of the face areas.  <a href="classmeshkernel_1_1_mesh2_d.html#aee516031de33d12a21a5d0aae1007162">More...</a><br /></td></tr>
<tr class="separator:aee516031de33d12a21a5d0aae1007162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281602c3eee4a57f2f06a89badafa04d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a281602c3eee4a57f2f06a89badafa04d">ComputeAspectRatios</a> (std::vector&lt; double &gt; &amp;aspectRatios)</td></tr>
<tr class="memdesc:a281602c3eee4a57f2f06a89badafa04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the aspect ratios (the ratios edges lengths to flow edges lengths)  <a href="classmeshkernel_1_1_mesh2_d.html#a281602c3eee4a57f2f06a89badafa04d">More...</a><br /></td></tr>
<tr class="separator:a281602c3eee4a57f2f06a89badafa04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70f0bfaf5a55b9b0a76bd6a3d98041f"><td class="memItemLeft" align="right" valign="top"><a id="ae70f0bfaf5a55b9b0a76bd6a3d98041f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ae70f0bfaf5a55b9b0a76bd6a3d98041f">ClassifyNodes</a> ()</td></tr>
<tr class="memdesc:ae70f0bfaf5a55b9b0a76bd6a3d98041f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classifies the nodes (makenetnodescoding) <br /></td></tr>
<tr class="separator:ae70f0bfaf5a55b9b0a76bd6a3d98041f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aadc845f5afa2319c01fb984288e3de"><td class="memItemLeft" align="right" valign="top"><a id="a9aadc845f5afa2319c01fb984288e3de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a9aadc845f5afa2319c01fb984288e3de">DeleteDegeneratedTriangles</a> ()</td></tr>
<tr class="memdesc:a9aadc845f5afa2319c01fb984288e3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes coinciding triangles. <br /></td></tr>
<tr class="separator:a9aadc845f5afa2319c01fb984288e3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4836ba2335da505e7c952bbc8706873b"><td class="memItemLeft" align="right" valign="top"><a id="a4836ba2335da505e7c952bbc8706873b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a4836ba2335da505e7c952bbc8706873b">TriangulateFaces</a> ()</td></tr>
<tr class="memdesc:a4836ba2335da505e7c952bbc8706873b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform non-triangular faces in triangular faces. <br /></td></tr>
<tr class="separator:a4836ba2335da505e7c952bbc8706873b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a323c8828549c59994bb20bbc5a7ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a40a323c8828549c59994bb20bbc5a7ab">MakeDualFace</a> (size_t node, double enlargementFactor, std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;dualFace)</td></tr>
<tr class="memdesc:a40a323c8828549c59994bb20bbc5a7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a dual face around the node, enlarged by a factor.  <a href="classmeshkernel_1_1_mesh2_d.html#a40a323c8828549c59994bb20bbc5a7ab">More...</a><br /></td></tr>
<tr class="separator:a40a323c8828549c59994bb20bbc5a7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5245c9e158f76dfbbd1cf12366cc98"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a4d5245c9e158f76dfbbd1cf12366cc98">SortedFacesAroundNode</a> (size_t node) const</td></tr>
<tr class="memdesc:a4d5245c9e158f76dfbbd1cf12366cc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the faces around a node, sorted in counter clock wise order.  <a href="classmeshkernel_1_1_mesh2_d.html#a4d5245c9e158f76dfbbd1cf12366cc98">More...</a><br /></td></tr>
<tr class="separator:a4d5245c9e158f76dfbbd1cf12366cc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf52d4c97ef09036a3110ab61fab031b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#acf52d4c97ef09036a3110ab61fab031b">MeshBoundaryToPolygon</a> (const std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygon)</td></tr>
<tr class="memdesc:acf52d4c97ef09036a3110ab61fab031b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all mesh boundaries to a vector of polygon nodes, including holes (copynetboundstopol)  <a href="classmeshkernel_1_1_mesh2_d.html#acf52d4c97ef09036a3110ab61fab031b">More...</a><br /></td></tr>
<tr class="separator:acf52d4c97ef09036a3110ab61fab031b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8462ca5491385d8351864f36b7dc5e99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a8462ca5491385d8351864f36b7dc5e99">WalkBoundaryFromNode</a> (const std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygonNodes, std::vector&lt; bool &gt; &amp;isVisited, size_t &amp;currentNode, std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;meshBoundaryPolygon) const</td></tr>
<tr class="memdesc:a8462ca5491385d8351864f36b7dc5e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a polygon from the meshboundary, by walking through the mesh.  <a href="classmeshkernel_1_1_mesh2_d.html#a8462ca5491385d8351864f36b7dc5e99">More...</a><br /></td></tr>
<tr class="separator:a8462ca5491385d8351864f36b7dc5e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d607450f4f095e28da4386939dc1ec"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a52d607450f4f095e28da4386939dc1ec">GetHangingEdges</a> () const</td></tr>
<tr class="memdesc:a52d607450f4f095e28da4386939dc1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the hanging edges.  <a href="classmeshkernel_1_1_mesh2_d.html#a52d607450f4f095e28da4386939dc1ec">More...</a><br /></td></tr>
<tr class="separator:a52d607450f4f095e28da4386939dc1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f04f13e20376dd7fccb5eb6c2c82ef"><td class="memItemLeft" align="right" valign="top"><a id="a61f04f13e20376dd7fccb5eb6c2c82ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a61f04f13e20376dd7fccb5eb6c2c82ef">DeleteHangingEdges</a> ()</td></tr>
<tr class="memdesc:a61f04f13e20376dd7fccb5eb6c2c82ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the hanging edges. <br /></td></tr>
<tr class="separator:a61f04f13e20376dd7fccb5eb6c2c82ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bc195a366c88af68ab87b9d2a5f032"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a97bc195a366c88af68ab87b9d2a5f032">PointFaceIndices</a> (const std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;points)</td></tr>
<tr class="memdesc:a97bc195a366c88af68ab87b9d2a5f032"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a collection of points, compute the face indices including them.  <a href="classmeshkernel_1_1_mesh2_d.html#a97bc195a366c88af68ab87b9d2a5f032">More...</a><br /></td></tr>
<tr class="separator:a97bc195a366c88af68ab87b9d2a5f032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cce62a059fa51a0c94b52f33a456eed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a6cce62a059fa51a0c94b52f33a456eed">DeleteMesh</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygon, int deletionOption, bool invertDeletion)</td></tr>
<tr class="memdesc:a6cce62a059fa51a0c94b52f33a456eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a mesh in a polygon, using several options (delnet)  <a href="classmeshkernel_1_1_mesh2_d.html#a6cce62a059fa51a0c94b52f33a456eed">More...</a><br /></td></tr>
<tr class="separator:a6cce62a059fa51a0c94b52f33a456eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc822de50acdf0f3cb964c1215a960a"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a5dc822de50acdf0f3cb964c1215a960a">IsSegmentCrossingABoundaryEdge</a> (const <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &amp;firstPoint, const <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &amp;secondPoint) const</td></tr>
<tr class="memdesc:a5dc822de50acdf0f3cb964c1215a960a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if a segment is crossing a face.  <a href="classmeshkernel_1_1_mesh2_d.html#a5dc822de50acdf0f3cb964c1215a960a">More...</a><br /></td></tr>
<tr class="separator:a5dc822de50acdf0f3cb964c1215a960a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8d2323884afc07dcf4e1efd2d699bd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a7a8d2323884afc07dcf4e1efd2d699bd">EdgesMaskOfFacesInPolygons</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, bool invertSelection, bool includeIntersected) const</td></tr>
<tr class="memdesc:a7a8d2323884afc07dcf4e1efd2d699bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masks the edges of all faces entirely included in all polygons.  <a href="classmeshkernel_1_1_mesh2_d.html#a7a8d2323884afc07dcf4e1efd2d699bd">More...</a><br /></td></tr>
<tr class="separator:a7a8d2323884afc07dcf4e1efd2d699bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0842f06cb37b04dea67fb797056cd216"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a0842f06cb37b04dea67fb797056cd216">NodeMaskFromEdgeMask</a> (std::vector&lt; int &gt; const &amp;edgeMask) const</td></tr>
<tr class="memdesc:a0842f06cb37b04dea67fb797056cd216"><td class="mdescLeft">&#160;</td><td class="mdescRight">From the edge mask compute the node mask.  <a href="classmeshkernel_1_1_mesh2_d.html#a0842f06cb37b04dea67fb797056cd216">More...</a><br /></td></tr>
<tr class="separator:a0842f06cb37b04dea67fb797056cd216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc47b25ff52ee8fd178b357c7abfe91"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#adbc47b25ff52ee8fd178b357c7abfe91">NodeMaskFromPolygon</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, bool inside) const</td></tr>
<tr class="memdesc:adbc47b25ff52ee8fd178b357c7abfe91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask all nodes included in all polygons.  <a href="classmeshkernel_1_1_mesh2_d.html#adbc47b25ff52ee8fd178b357c7abfe91">More...</a><br /></td></tr>
<tr class="separator:adbc47b25ff52ee8fd178b357c7abfe91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:a05bc04f7af254a40598f8b9627da6e60 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a05bc04f7af254a40598f8b9627da6e60"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a05bc04f7af254a40598f8b9627da6e60">Mesh</a> ()=default</td></tr>
<tr class="memdesc:a05bc04f7af254a40598f8b9627da6e60 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a05bc04f7af254a40598f8b9627da6e60 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a21a6199afcf9444f0e7ae17856dcf inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a77a21a6199afcf9444f0e7ae17856dcf">Mesh</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a7fda31b0d2488c53f4b00c5d2e764fb7">Edge</a> &gt; &amp;edges, const std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:a77a21a6199afcf9444f0e7ae17856dcf inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh starting from the edges and nodes.  <a href="classmeshkernel_1_1_mesh.html#a77a21a6199afcf9444f0e7ae17856dcf">More...</a><br /></td></tr>
<tr class="separator:a77a21a6199afcf9444f0e7ae17856dcf inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4954d57baf24b3792520bcb81b0d733a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a4954d57baf24b3792520bcb81b0d733a">IsNodeOnBoundary</a> (size_t node) const</td></tr>
<tr class="memdesc:a4954d57baf24b3792520bcb81b0d733a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if a node is on boundary.  <a href="classmeshkernel_1_1_mesh.html#a4954d57baf24b3792520bcb81b0d733a">More...</a><br /></td></tr>
<tr class="separator:a4954d57baf24b3792520bcb81b0d733a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdde73c3f0dd734948065fc83bb7a61 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aacdde73c3f0dd734948065fc83bb7a61">GetNumNodes</a> () const</td></tr>
<tr class="memdesc:aacdde73c3f0dd734948065fc83bb7a61 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid nodes.  <a href="classmeshkernel_1_1_mesh.html#aacdde73c3f0dd734948065fc83bb7a61">More...</a><br /></td></tr>
<tr class="separator:aacdde73c3f0dd734948065fc83bb7a61 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5150280bdba56884de15211a34e64155 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5150280bdba56884de15211a34e64155">GetNumEdges</a> () const</td></tr>
<tr class="memdesc:a5150280bdba56884de15211a34e64155 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid edges.  <a href="classmeshkernel_1_1_mesh.html#a5150280bdba56884de15211a34e64155">More...</a><br /></td></tr>
<tr class="separator:a5150280bdba56884de15211a34e64155 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50abbc0382968330e4a530e84f093194 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a50abbc0382968330e4a530e84f093194">GetNumFaces</a> () const</td></tr>
<tr class="memdesc:a50abbc0382968330e4a530e84f093194 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid faces.  <a href="classmeshkernel_1_1_mesh.html#a50abbc0382968330e4a530e84f093194">More...</a><br /></td></tr>
<tr class="separator:a50abbc0382968330e4a530e84f093194 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ad9a0403cc4a9e339a54c098e14500 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ad5ad9a0403cc4a9e339a54c098e14500">GetNumFaceEdges</a> (size_t faceIndex) const</td></tr>
<tr class="memdesc:ad5ad9a0403cc4a9e339a54c098e14500 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges for a face.  <a href="classmeshkernel_1_1_mesh.html#ad5ad9a0403cc4a9e339a54c098e14500">More...</a><br /></td></tr>
<tr class="separator:ad5ad9a0403cc4a9e339a54c098e14500 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee608ef36ed49384225afcad7cfeee62 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aee608ef36ed49384225afcad7cfeee62">GetNumEdgesFaces</a> (size_t edgeIndex) const</td></tr>
<tr class="memdesc:aee608ef36ed49384225afcad7cfeee62 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of faces an edges shares.  <a href="classmeshkernel_1_1_mesh.html#aee608ef36ed49384225afcad7cfeee62">More...</a><br /></td></tr>
<tr class="separator:aee608ef36ed49384225afcad7cfeee62 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2741b112d098254135f0e116c8ea8b5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ab2741b112d098254135f0e116c8ea8b5">IsEdgeOnBoundary</a> (size_t edge) const</td></tr>
<tr class="memdesc:ab2741b112d098254135f0e116c8ea8b5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if an edge is on boundary.  <a href="classmeshkernel_1_1_mesh.html#ab2741b112d098254135f0e116c8ea8b5">More...</a><br /></td></tr>
<tr class="separator:ab2741b112d098254135f0e116c8ea8b5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0332ff6932b642a71861b54e851e3728 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a0332ff6932b642a71861b54e851e3728">IsFaceOnBoundary</a> (size_t face) const</td></tr>
<tr class="memdesc:a0332ff6932b642a71861b54e851e3728 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if a face is on boundary.  <a href="classmeshkernel_1_1_mesh.html#a0332ff6932b642a71861b54e851e3728">More...</a><br /></td></tr>
<tr class="separator:a0332ff6932b642a71861b54e851e3728 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c88b44c65b3484ee25587b789dbc562 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a0c88b44c65b3484ee25587b789dbc562">MergeTwoNodes</a> (size_t startNode, size_t endNode)</td></tr>
<tr class="memdesc:a0c88b44c65b3484ee25587b789dbc562 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two mesh nodes.  <a href="classmeshkernel_1_1_mesh.html#a0c88b44c65b3484ee25587b789dbc562">More...</a><br /></td></tr>
<tr class="separator:a0c88b44c65b3484ee25587b789dbc562 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c62be0cf9f5bf96f52c19f0e420dd80 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a6c62be0cf9f5bf96f52c19f0e420dd80">MergeNodesInPolygon</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, double mergingDistance)</td></tr>
<tr class="memdesc:a6c62be0cf9f5bf96f52c19f0e420dd80 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge close mesh nodes inside a polygon (MERGENODESINPOLYGON)  <a href="classmeshkernel_1_1_mesh.html#a6c62be0cf9f5bf96f52c19f0e420dd80">More...</a><br /></td></tr>
<tr class="separator:a6c62be0cf9f5bf96f52c19f0e420dd80 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baba75ddd46f4af5465d947f40fba3c inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a9baba75ddd46f4af5465d947f40fba3c">ConnectNodes</a> (size_t startNode, size_t endNode)</td></tr>
<tr class="memdesc:a9baba75ddd46f4af5465d947f40fba3c inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect two existing nodes, forming a new edge (connectdbn)  <a href="classmeshkernel_1_1_mesh.html#a9baba75ddd46f4af5465d947f40fba3c">More...</a><br /></td></tr>
<tr class="separator:a9baba75ddd46f4af5465d947f40fba3c inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057fc512938636517f87d7724e9dd8c0 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a057fc512938636517f87d7724e9dd8c0">InsertNode</a> (const <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &amp;newPoint)</td></tr>
<tr class="memdesc:a057fc512938636517f87d7724e9dd8c0 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new node in the mesh (setnewpoint)  <a href="classmeshkernel_1_1_mesh.html#a057fc512938636517f87d7724e9dd8c0">More...</a><br /></td></tr>
<tr class="separator:a057fc512938636517f87d7724e9dd8c0 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970fe059df6ae680e097513f4c012165 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a970fe059df6ae680e097513f4c012165">DeleteNode</a> (size_t node)</td></tr>
<tr class="memdesc:a970fe059df6ae680e097513f4c012165 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a node.  <a href="classmeshkernel_1_1_mesh.html#a970fe059df6ae680e097513f4c012165">More...</a><br /></td></tr>
<tr class="separator:a970fe059df6ae680e097513f4c012165 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7206ad2b436bd04bb7468d4cb32a0a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a2e7206ad2b436bd04bb7468d4cb32a0a">FindEdge</a> (size_t firstNodeIndex, size_t secondNodeIndex) const</td></tr>
<tr class="memdesc:a2e7206ad2b436bd04bb7468d4cb32a0a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the edge sharing two nodes.  <a href="classmeshkernel_1_1_mesh.html#a2e7206ad2b436bd04bb7468d4cb32a0a">More...</a><br /></td></tr>
<tr class="separator:a2e7206ad2b436bd04bb7468d4cb32a0a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a10c1455f2f06a48a16be08ce25dd8 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ae0a10c1455f2f06a48a16be08ce25dd8">MoveNode</a> (<a class="el" href="structmeshkernel_1_1_point.html">Point</a> newPoint, size_t nodeindex)</td></tr>
<tr class="memdesc:ae0a10c1455f2f06a48a16be08ce25dd8 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a node to a new location.  <a href="classmeshkernel_1_1_mesh.html#ae0a10c1455f2f06a48a16be08ce25dd8">More...</a><br /></td></tr>
<tr class="separator:ae0a10c1455f2f06a48a16be08ce25dd8 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b45fd9131625b769264f4b4e533d1e inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a21b45fd9131625b769264f4b4e533d1e">FindNodeCloseToAPoint</a> (<a class="el" href="structmeshkernel_1_1_point.html">Point</a> point, const std::vector&lt; bool &gt; &amp;nodeMask)</td></tr>
<tr class="memdesc:a21b45fd9131625b769264f4b4e533d1e inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a node close to a point.  <a href="classmeshkernel_1_1_mesh.html#a21b45fd9131625b769264f4b4e533d1e">More...</a><br /></td></tr>
<tr class="separator:a21b45fd9131625b769264f4b4e533d1e inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bf37401f505cb1df233cf6f1074c8b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a13bf37401f505cb1df233cf6f1074c8b">FindNodeCloseToAPoint</a> (<a class="el" href="structmeshkernel_1_1_point.html">Point</a> const &amp;point, double searchRadius)</td></tr>
<tr class="memdesc:a13bf37401f505cb1df233cf6f1074c8b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a node close to a point.  <a href="classmeshkernel_1_1_mesh.html#a13bf37401f505cb1df233cf6f1074c8b">More...</a><br /></td></tr>
<tr class="separator:a13bf37401f505cb1df233cf6f1074c8b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd44fab3e349b6f92793b53d7e377c2b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#acd44fab3e349b6f92793b53d7e377c2b">DeleteEdge</a> (size_t edge)</td></tr>
<tr class="memdesc:acd44fab3e349b6f92793b53d7e377c2b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes an edge.  <a href="classmeshkernel_1_1_mesh.html#acd44fab3e349b6f92793b53d7e377c2b">More...</a><br /></td></tr>
<tr class="separator:acd44fab3e349b6f92793b53d7e377c2b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c65224cfb84d53cb81fb81289673c6 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a60c65224cfb84d53cb81fb81289673c6">FindEdgeCloseToAPoint</a> (<a class="el" href="structmeshkernel_1_1_point.html">Point</a> point)</td></tr>
<tr class="separator:a60c65224cfb84d53cb81fb81289673c6 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e9c67ceb1dd961162d268fe138dcb4 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a26e9c67ceb1dd961162d268fe138dcb4">FindCommonNode</a> (size_t firstEdgeIndex, size_t secondEdgeIndex) const</td></tr>
<tr class="memdesc:a26e9c67ceb1dd961162d268fe138dcb4 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the common node two edges share This method uses return parameters since the success is evaluated in a hot loop.  <a href="classmeshkernel_1_1_mesh.html#a26e9c67ceb1dd961162d268fe138dcb4">More...</a><br /></td></tr>
<tr class="separator:a26e9c67ceb1dd961162d268fe138dcb4 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d007633404f80e3fb1f2e789bc2859f inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a2d007633404f80e3fb1f2e789bc2859f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a2d007633404f80e3fb1f2e789bc2859f">ComputeEdgesLengths</a> ()</td></tr>
<tr class="memdesc:a2d007633404f80e3fb1f2e789bc2859f inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the lengths of all edges in one go. <br /></td></tr>
<tr class="separator:a2d007633404f80e3fb1f2e789bc2859f inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b2912121a8b224b96f3f8e15397884 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a48b2912121a8b224b96f3f8e15397884"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a48b2912121a8b224b96f3f8e15397884">ComputeEdgesCenters</a> ()</td></tr>
<tr class="memdesc:a48b2912121a8b224b96f3f8e15397884 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the edges centers in one go. <br /></td></tr>
<tr class="separator:a48b2912121a8b224b96f3f8e15397884 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38045736a55485cb9fe2ad078928c5b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="ab38045736a55485cb9fe2ad078928c5b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ab38045736a55485cb9fe2ad078928c5b">NodeAdministration</a> ()</td></tr>
<tr class="memdesc:ab38045736a55485cb9fe2ad078928c5b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node administration (setnodadmin) <br /></td></tr>
<tr class="separator:ab38045736a55485cb9fe2ad078928c5b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadf16bf95337fec05384a2dc07798fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="adadf16bf95337fec05384a2dc07798fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#adadf16bf95337fec05384a2dc07798fe">DeleteInvalidNodesAndEdges</a> ()</td></tr>
<tr class="memdesc:adadf16bf95337fec05384a2dc07798fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all invalid nodes and edges. <br /></td></tr>
<tr class="separator:adadf16bf95337fec05384a2dc07798fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2c7373bafa1d4429c330876f445993 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a4f2c7373bafa1d4429c330876f445993"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a4f2c7373bafa1d4429c330876f445993">AdministrateNodesEdges</a> ()</td></tr>
<tr class="memdesc:a4f2c7373bafa1d4429c330876f445993 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform node and edges administration. <br /></td></tr>
<tr class="separator:a4f2c7373bafa1d4429c330876f445993 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee0e0e1b31c6723772fa1f4710efe24 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a3ee0e0e1b31c6723772fa1f4710efe24">SortEdgesInCounterClockWiseOrder</a> (size_t startNode, size_t endNode)</td></tr>
<tr class="memdesc:a3ee0e0e1b31c6723772fa1f4710efe24 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort mesh edges around a node in counterclockwise order (Sort_links_ccw)  <a href="classmeshkernel_1_1_mesh.html#a3ee0e0e1b31c6723772fa1f4710efe24">More...</a><br /></td></tr>
<tr class="separator:a3ee0e0e1b31c6723772fa1f4710efe24 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f948cb7c8e5c7552f1504e2c446391 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a49f948cb7c8e5c7552f1504e2c446391">ComputeMaxLengthSurroundingEdges</a> (size_t node)</td></tr>
<tr class="memdesc:a49f948cb7c8e5c7552f1504e2c446391 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the max length of the edges connected to a node.  <a href="classmeshkernel_1_1_mesh.html#a49f948cb7c8e5c7552f1504e2c446391">More...</a><br /></td></tr>
<tr class="separator:a49f948cb7c8e5c7552f1504e2c446391 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed41638cbd948b4f6bf35888ab5e636 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a0ed41638cbd948b4f6bf35888ab5e636">BuildTree</a> (<a class="el" href="namespacemeshkernel.html#acb97240557899a7564683794daab5016">MeshLocations</a> meshLocation)</td></tr>
<tr class="memdesc:a0ed41638cbd948b4f6bf35888ab5e636 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the rtree for the corresponding location.  <a href="classmeshkernel_1_1_mesh.html#a0ed41638cbd948b4f6bf35888ab5e636">More...</a><br /></td></tr>
<tr class="separator:a0ed41638cbd948b4f6bf35888ab5e636 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f23ddeddeb6e20220f6d250244d9ef inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a51f23ddeddeb6e20220f6d250244d9ef">SearchNearestLocation</a> (<a class="el" href="structmeshkernel_1_1_point.html">Point</a> point, <a class="el" href="namespacemeshkernel.html#acb97240557899a7564683794daab5016">MeshLocations</a> meshLocation)</td></tr>
<tr class="memdesc:a51f23ddeddeb6e20220f6d250244d9ef inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search all points sorted by proximity to another point.  <a href="classmeshkernel_1_1_mesh.html#a51f23ddeddeb6e20220f6d250244d9ef">More...</a><br /></td></tr>
<tr class="separator:a51f23ddeddeb6e20220f6d250244d9ef inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69b35ee59cd2cf2921af26acbde9500 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ac69b35ee59cd2cf2921af26acbde9500">SearchNearestLocation</a> (<a class="el" href="structmeshkernel_1_1_point.html">Point</a> point, double squaredRadius, <a class="el" href="namespacemeshkernel.html#acb97240557899a7564683794daab5016">MeshLocations</a> meshLocation)</td></tr>
<tr class="memdesc:ac69b35ee59cd2cf2921af26acbde9500 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the nearest point within a radius to another point.  <a href="classmeshkernel_1_1_mesh.html#ac69b35ee59cd2cf2921af26acbde9500">More...</a><br /></td></tr>
<tr class="separator:ac69b35ee59cd2cf2921af26acbde9500 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad73da129c9d86466c00c8fe0d30c4f5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aad73da129c9d86466c00c8fe0d30c4f5">SearchLocations</a> (<a class="el" href="structmeshkernel_1_1_point.html">Point</a> point, double squaredRadius, <a class="el" href="namespacemeshkernel.html#acb97240557899a7564683794daab5016">MeshLocations</a> meshLocation)</td></tr>
<tr class="memdesc:aad73da129c9d86466c00c8fe0d30c4f5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the nearest points within a radius to another point.  <a href="classmeshkernel_1_1_mesh.html#aad73da129c9d86466c00c8fe0d30c4f5">More...</a><br /></td></tr>
<tr class="separator:aad73da129c9d86466c00c8fe0d30c4f5 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2980d79fc65103b9a9cb6cf69ed5f00 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ab2980d79fc65103b9a9cb6cf69ed5f00">GetNumLocations</a> (<a class="el" href="namespacemeshkernel.html#acb97240557899a7564683794daab5016">MeshLocations</a> meshLocation) const</td></tr>
<tr class="memdesc:ab2980d79fc65103b9a9cb6cf69ed5f00 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the search results. To be used after <a class="el" href="classmeshkernel_1_1_mesh.html#aad73da129c9d86466c00c8fe0d30c4f5">SearchLocations</a> or <a class="el" href="classmeshkernel_1_1_mesh.html#a51f23ddeddeb6e20220f6d250244d9ef">SearchNearestLocation</a>.  <a href="classmeshkernel_1_1_mesh.html#ab2980d79fc65103b9a9cb6cf69ed5f00">More...</a><br /></td></tr>
<tr class="separator:ab2980d79fc65103b9a9cb6cf69ed5f00 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5400f796bfcc377c1b1c98c262340215 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5400f796bfcc377c1b1c98c262340215">GetLocationsIndices</a> (size_t index, <a class="el" href="namespacemeshkernel.html#acb97240557899a7564683794daab5016">MeshLocations</a> meshLocation)</td></tr>
<tr class="memdesc:a5400f796bfcc377c1b1c98c262340215 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index of the location, sorted by proximity. To be used after SearchNearestLocation or SearchNearestLocation.  <a href="classmeshkernel_1_1_mesh.html#a5400f796bfcc377c1b1c98c262340215">More...</a><br /></td></tr>
<tr class="separator:a5400f796bfcc377c1b1c98c262340215 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5dbb10dd61580b4d81c8c297b77e602 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aa5dbb10dd61580b4d81c8c297b77e602">ComputeLocations</a> (<a class="el" href="namespacemeshkernel.html#acb97240557899a7564683794daab5016">MeshLocations</a> location) const</td></tr>
<tr class="memdesc:aa5dbb10dd61580b4d81c8c297b77e602 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a vector with the mesh locations coordinates (nodes, edges or faces coordinates).  <a href="classmeshkernel_1_1_mesh.html#aa5dbb10dd61580b4d81c8c297b77e602">More...</a><br /></td></tr>
<tr class="separator:aa5dbb10dd61580b4d81c8c297b77e602 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae11e12a202c2e4d2ee57fae97f9881 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#abae11e12a202c2e4d2ee57fae97f9881">operator+=</a> (<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> const &amp;rhs)</td></tr>
<tr class="memdesc:abae11e12a202c2e4d2ee57fae97f9881 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add meshes: result is a mesh composed of the additions firstMesh += secondmesh results in the second mesh being added to firstMesh.  <a href="classmeshkernel_1_1_mesh.html#abae11e12a202c2e4d2ee57fae97f9881">More...</a><br /></td></tr>
<tr class="separator:abae11e12a202c2e4d2ee57fae97f9881 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad49b984915b56fa7e5e1fe2fe9e52007"><td class="memItemLeft" align="right" valign="top"><a id="ad49b984915b56fa7e5e1fe2fe9e52007"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ad49b984915b56fa7e5e1fe2fe9e52007">m_maxNumNeighbours</a> = 0</td></tr>
<tr class="memdesc:ad49b984915b56fa7e5e1fe2fe9e52007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of neighbours. <br /></td></tr>
<tr class="separator:ad49b984915b56fa7e5e1fe2fe9e52007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:a130c483ec12ccfc11cddc0b1162a318e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a130c483ec12ccfc11cddc0b1162a318e"></a>
std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a130c483ec12ccfc11cddc0b1162a318e">m_nodes</a></td></tr>
<tr class="memdesc:a130c483ec12ccfc11cddc0b1162a318e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mesh nodes (xk, yk) <br /></td></tr>
<tr class="separator:a130c483ec12ccfc11cddc0b1162a318e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f5e178d218082170fbde344f7f6540 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="af0f5e178d218082170fbde344f7f6540"></a>
std::vector&lt; std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#af0f5e178d218082170fbde344f7f6540">m_nodesEdges</a></td></tr>
<tr class="memdesc:af0f5e178d218082170fbde344f7f6540 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each node, the indices of connected edges (nodlin) <br /></td></tr>
<tr class="separator:af0f5e178d218082170fbde344f7f6540 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7421883d556cdc8b8fd52996eaa860 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a9a7421883d556cdc8b8fd52996eaa860"></a>
std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a9a7421883d556cdc8b8fd52996eaa860">m_nodesNumEdges</a></td></tr>
<tr class="memdesc:a9a7421883d556cdc8b8fd52996eaa860 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each node, the number of connected edges (nmk) <br /></td></tr>
<tr class="separator:a9a7421883d556cdc8b8fd52996eaa860 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375882f55356a94885b680bc5092e426 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a375882f55356a94885b680bc5092e426"></a>
std::vector&lt; std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a375882f55356a94885b680bc5092e426">m_nodesNodes</a></td></tr>
<tr class="memdesc:a375882f55356a94885b680bc5092e426 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each node, its neighbors. <br /></td></tr>
<tr class="separator:a375882f55356a94885b680bc5092e426 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69248de9529d1c0ad698d056760e5900 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a69248de9529d1c0ad698d056760e5900"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a69248de9529d1c0ad698d056760e5900">m_nodesTypes</a></td></tr>
<tr class="memdesc:a69248de9529d1c0ad698d056760e5900 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The node types (nb) <br /></td></tr>
<tr class="separator:a69248de9529d1c0ad698d056760e5900 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b337f739ad083ffe320366f6e9dc0e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a84b337f739ad083ffe320366f6e9dc0e"></a>
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a7fda31b0d2488c53f4b00c5d2e764fb7">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a84b337f739ad083ffe320366f6e9dc0e">m_edges</a></td></tr>
<tr class="memdesc:a84b337f739ad083ffe320366f6e9dc0e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edges, defined as first and second node(kn) <br /></td></tr>
<tr class="separator:a84b337f739ad083ffe320366f6e9dc0e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8342506765b2351d1588cc57bd646ea1 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a8342506765b2351d1588cc57bd646ea1"></a>
std::vector&lt; std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a8342506765b2351d1588cc57bd646ea1">m_edgesFaces</a></td></tr>
<tr class="memdesc:a8342506765b2351d1588cc57bd646ea1 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each edge, the shared face index (lne) <br /></td></tr>
<tr class="separator:a8342506765b2351d1588cc57bd646ea1 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace24771b055caf16b816d77cda39114d inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="ace24771b055caf16b816d77cda39114d"></a>
std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ace24771b055caf16b816d77cda39114d">m_edgesNumFaces</a></td></tr>
<tr class="memdesc:ace24771b055caf16b816d77cda39114d inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each edge, the number of shared faces(lnn) <br /></td></tr>
<tr class="separator:ace24771b055caf16b816d77cda39114d inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff01e492e6674565a62206fdead6762 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a5ff01e492e6674565a62206fdead6762"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5ff01e492e6674565a62206fdead6762">m_edgeLengths</a></td></tr>
<tr class="memdesc:a5ff01e492e6674565a62206fdead6762 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edge lengths. <br /></td></tr>
<tr class="separator:a5ff01e492e6674565a62206fdead6762 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231d2889405c66b1b5e4db91d86a6ee8 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a231d2889405c66b1b5e4db91d86a6ee8"></a>
std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a231d2889405c66b1b5e4db91d86a6ee8">m_edgesCenters</a></td></tr>
<tr class="memdesc:a231d2889405c66b1b5e4db91d86a6ee8 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edges centers. <br /></td></tr>
<tr class="separator:a231d2889405c66b1b5e4db91d86a6ee8 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e91901c65f4ee1962d2be971f5a815 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a83e91901c65f4ee1962d2be971f5a815"></a>
std::vector&lt; std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a83e91901c65f4ee1962d2be971f5a815">m_facesNodes</a></td></tr>
<tr class="memdesc:a83e91901c65f4ee1962d2be971f5a815 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nodes composing the faces, in ccw order (netcellNod) <br /></td></tr>
<tr class="separator:a83e91901c65f4ee1962d2be971f5a815 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49fc4cf78fe81543ea2669738d4cb3b inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="ac49fc4cf78fe81543ea2669738d4cb3b"></a>
std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ac49fc4cf78fe81543ea2669738d4cb3b">m_numFacesNodes</a></td></tr>
<tr class="memdesc:ac49fc4cf78fe81543ea2669738d4cb3b inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nodes composing the face (netcellN) <br /></td></tr>
<tr class="separator:ac49fc4cf78fe81543ea2669738d4cb3b inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4858326d1ee3e286e5157339f543b06 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="ad4858326d1ee3e286e5157339f543b06"></a>
std::vector&lt; std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ad4858326d1ee3e286e5157339f543b06">m_facesEdges</a></td></tr>
<tr class="memdesc:ad4858326d1ee3e286e5157339f543b06 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edge indices composing the face (netcelllin) <br /></td></tr>
<tr class="separator:ad4858326d1ee3e286e5157339f543b06 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3342f40eb06afd71cc336010e641a227 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a3342f40eb06afd71cc336010e641a227"></a>
std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a3342f40eb06afd71cc336010e641a227">m_facesCircumcenters</a></td></tr>
<tr class="memdesc:a3342f40eb06afd71cc336010e641a227 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The face circumcenters the face circumcenter (xz, yz) <br /></td></tr>
<tr class="separator:a3342f40eb06afd71cc336010e641a227 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79821f2e74e22834dcfce0ce0a326e2e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a79821f2e74e22834dcfce0ce0a326e2e"></a>
std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a79821f2e74e22834dcfce0ce0a326e2e">m_facesMassCenters</a></td></tr>
<tr class="memdesc:a79821f2e74e22834dcfce0ce0a326e2e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The faces centers of mass (xzw, yzw) <br /></td></tr>
<tr class="separator:a79821f2e74e22834dcfce0ce0a326e2e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b24f1ea21171bfd6f803b06a4997d56 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a2b24f1ea21171bfd6f803b06a4997d56"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a2b24f1ea21171bfd6f803b06a4997d56">m_faceArea</a></td></tr>
<tr class="memdesc:a2b24f1ea21171bfd6f803b06a4997d56 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The face area. <br /></td></tr>
<tr class="separator:a2b24f1ea21171bfd6f803b06a4997d56 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c05988ff2a54a0ddf3082c7e4aeeb6 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a01c05988ff2a54a0ddf3082c7e4aeeb6"></a>
<a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a01c05988ff2a54a0ddf3082c7e4aeeb6">m_projection</a></td></tr>
<tr class="memdesc:a01c05988ff2a54a0ddf3082c7e4aeeb6 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The projection used. <br /></td></tr>
<tr class="separator:a01c05988ff2a54a0ddf3082c7e4aeeb6 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fa3b6615a02516abcb7609abfdb44b inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="ad9fa3b6615a02516abcb7609abfdb44b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ad9fa3b6615a02516abcb7609abfdb44b">m_nodesRTreeRequiresUpdate</a> = true</td></tr>
<tr class="memdesc:ad9fa3b6615a02516abcb7609abfdb44b inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">m_nodesRTree requires an update <br /></td></tr>
<tr class="separator:ad9fa3b6615a02516abcb7609abfdb44b inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a7b51b23ecc45e373af1a53414804e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a16a7b51b23ecc45e373af1a53414804e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a16a7b51b23ecc45e373af1a53414804e">m_edgesRTreeRequiresUpdate</a> = true</td></tr>
<tr class="memdesc:a16a7b51b23ecc45e373af1a53414804e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">m_edgesRTree requires an update <br /></td></tr>
<tr class="separator:a16a7b51b23ecc45e373af1a53414804e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ab281fde2432c3de99d4f7148bbe3a inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a10ab281fde2432c3de99d4f7148bbe3a"></a>
<a class="el" href="classmeshkernel_1_1_r_tree.html">RTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a10ab281fde2432c3de99d4f7148bbe3a">m_nodesRTree</a></td></tr>
<tr class="memdesc:a10ab281fde2432c3de99d4f7148bbe3a inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial R-Tree used to inquire node nodes. <br /></td></tr>
<tr class="separator:a10ab281fde2432c3de99d4f7148bbe3a inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb30c32af4e98b0772e8c3d55a670a8 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="abbb30c32af4e98b0772e8c3d55a670a8"></a>
<a class="el" href="classmeshkernel_1_1_r_tree.html">RTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#abbb30c32af4e98b0772e8c3d55a670a8">m_edgesRTree</a></td></tr>
<tr class="memdesc:abbb30c32af4e98b0772e8c3d55a670a8 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial R-Tree used to inquire edges centers. <br /></td></tr>
<tr class="separator:abbb30c32af4e98b0772e8c3d55a670a8 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d44668af534ba075870c6be5567c9b7 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a0d44668af534ba075870c6be5567c9b7"></a>
<a class="el" href="classmeshkernel_1_1_r_tree.html">RTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a0d44668af534ba075870c6be5567c9b7">m_facesRTree</a></td></tr>
<tr class="memdesc:a0d44668af534ba075870c6be5567c9b7 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial R-Tree used to inquire face circumcenters. <br /></td></tr>
<tr class="separator:a0d44668af534ba075870c6be5567c9b7 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class derived from <a class="el" href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2...">Mesh</a>, which describes unstructures 2d meshes. </p>
<p>When communicating with the client only unstructured meshes are used. Some algorithms generate curvilinear grids, but these are converted to a mesh instance when communicating with the client. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac667a2395d4b205d7c4be2536bc301eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac667a2395d4b205d7c4be2536bc301eb">&#9670;&nbsp;</a></span>Mesh2D() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh2D::Mesh2D </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a7fda31b0d2488c53f4b00c5d2e764fb7">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a mesh2d starting from the edges and nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>The input edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>The input nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The projection to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">administration</td><td>Type of administration to perform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ba8740c34f7b23d18e022c04b15f477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba8740c34f7b23d18e022c04b15f477">&#9670;&nbsp;</a></span>Mesh2D() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh2D::Mesh2D </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a7fda31b0d2488c53f4b00c5d2e764fb7">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>faceNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>numFaceNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a mesh2d from face nodes and num face nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>The input edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>The input nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceNodes</td><td>The input face nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numFaceNodes</td><td>For each face, the number of nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The mesh projection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae466a7ef61c51eb720f50d31ed94ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae466a7ef61c51eb720f50d31ed94ca1">&#9670;&nbsp;</a></span>Mesh2D() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh2D::Mesh2D </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create triangular grid from nodes (triangulatesamplestonetwork) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>Input nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>Selection polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The projection to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a281602c3eee4a57f2f06a89badafa04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281602c3eee4a57f2f06a89badafa04d">&#9670;&nbsp;</a></span>ComputeAspectRatios()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::ComputeAspectRatios </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>aspectRatios</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the aspect ratios (the ratios edges lengths to flow edges lengths) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">aspectRatios</td><td>The aspect ratios (passed as reference to avoid re-allocation) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee615054d70e2fb2879d6d6b730288ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee615054d70e2fb2879d6d6b730288ab">&#9670;&nbsp;</a></span>ComputeFaceCircumenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmeshkernel_1_1_point.html">Point</a> meshkernel::Mesh2D::ComputeFaceCircumenter </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgesNumFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a closed polygon, compute the circumcenter of a face (getcircumcenter) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">polygon</td><td>Cache storing the face nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edgesNumFaces</td><td>For meshes, the number of faces sharing the edges </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed circumcenter </dd></dl>

</div>
</div>
<a id="a1a95c66b7653e2d9f2dffee78bc2cdbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a95c66b7653e2d9f2dffee78bc2cdbd">&#9670;&nbsp;</a></span>ComputeFaceClosedPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::ComputeFaceClosedPolygon </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>faceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygonNodesCache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a face create a closed polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face index </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">polygonNodesCache</td><td>The cache array to be filled with the nodes values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a821f4925cc54788fc2637dd58a43d70b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821f4925cc54788fc2637dd58a43d70b">&#9670;&nbsp;</a></span>ComputeFaceClosedPolygonWithLocalMappings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::ComputeFaceClosedPolygonWithLocalMappings </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>faceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygonNodesCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>localNodeIndicesCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>globalEdgeIndicesCache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a face create a closed polygon and fill local mapping caches (get_cellpolygon) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">polygonNodesCache</td><td>The node cache array filled with the nodes values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">localNodeIndicesCache</td><td>The consecutive node index in polygonNodesCache (0, 1, 2,...) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">globalEdgeIndicesCache</td><td>The edge cache array filled with the global edge indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cce62a059fa51a0c94b52f33a456eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cce62a059fa51a0c94b52f33a456eed">&#9670;&nbsp;</a></span>DeleteMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::DeleteMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deletionOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invertDeletion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a mesh in a polygon, using several options (delnet) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The polygon where to perform the operation If this <a class="el" href="classmeshkernel_1_1_polygons.html" title="A class describing polygons.">Polygons</a> instance contains multiple polygons, the first one will be taken. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deletionOption</td><td>The deletion option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">invertDeletion</td><td>Inverts the selected node to delete (instead of outside the polygon, inside the polygon) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6855534ffcff0ca5ac4ce4e1bc4ca229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6855534ffcff0ca5ac4ce4e1bc4ca229">&#9670;&nbsp;</a></span>DeleteSmallFlowEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::DeleteSmallFlowEdges </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>smallFlowEdgesThreshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes small flow edges (removesmallflowlinks, part 1) </p>
<p>An unstructured mesh can be used to calculate water flow. This involves a pressure gradient between the circumcenters of neighbouring faces. That procedure is numerically unreliable when the distance between face circumcenters (flow edges) becomes too small. Let's consider the following figure </p><div class="image">
<object type="image/svg+xml" data="coincide_circumcenter.svg" style="pointer-events: none;"></object>
<div class="caption">
Coincide circumcenter</div></div>
<p> The algorithm works as follow:</p>
<ul>
<li>Any degenerated triangle (e.g. those having a coinciding node) is removed by collapsing the second and third node into the first one.</li>
<li><p class="startli">The edges crossing small flow edges are found. The flow edge length is computed from the face circumcenters and compared to an estimated cut off distance. The cutoff distance is computed using the face areas as follow:</p>
<p class="startli">\(\textrm{cutOffDistance} = \textrm{threshold} \cdot 0.5 \cdot (\sqrt{\textrm{Area}_I}+\sqrt{\textrm{Area}_{II}})\)</p>
</li>
<li>All small flow edges are flagged with invalid indices and removed from the mesh. Removal occors in the <a class="el" href="classmeshkernel_1_1_mesh2_d.html#adf046d573135e33e8074b18b6d456008">Mesh2D::Administrate</a> method. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smallFlowEdgesThreshold</td><td>The configurable threshold for detecting the small flow edges </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="af03d80377cafe9fdfb22545423fb8fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03d80377cafe9fdfb22545423fb8fa6">&#9670;&nbsp;</a></span>DeleteSmallTrianglesAtBoundaries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::DeleteSmallTrianglesAtBoundaries </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minFractionalAreaTriangles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes small triangles at the boundaries (removesmallflowlinks, part 2) </p>
<p>This algorithm removes triangles having the following properties:</p><ul>
<li>The are at mesh boundary.</li>
<li>One or more neighboring faces are non-triangles.</li>
<li>The ratio of the face area to the average area of neighboring non triangles is less than a minimum ratio (defaults to 0.2).</li>
<li>The absolute cosine of one internal angle is less than 0.2.</li>
</ul>
<p>These triangles having the above properties are merged by collapsing the face nodes to the node having the minimum absolute cosine (e.g. the node where the internal angle is closer to 90 degrees). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minFractionalAreaTriangles</td><td>Small triangles at the boundaries will be eliminated. This threshold is the ration of the face area to the average area of neighboring faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a8d2323884afc07dcf4e1efd2d699bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8d2323884afc07dcf4e1efd2d699bd">&#9670;&nbsp;</a></span>EdgesMaskOfFacesInPolygons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; meshkernel::Mesh2D::EdgesMaskOfFacesInPolygons </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invertSelection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeIntersected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Masks the edges of all faces entirely included in all polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The selection polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">invertSelection</td><td>Invert selection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">includeIntersected</td><td>Included the edges intersected by the polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edge mask </dd></dl>

</div>
</div>
<a id="a5a094e46fb97f0e00772213b38922a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a094e46fb97f0e00772213b38922a3a">&#9670;&nbsp;</a></span>GetEdgesCrossingSmallFlowEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; meshkernel::Mesh2D::GetEdgesCrossingSmallFlowEdges </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>smallFlowEdgesThreshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the edges crossing the small flow edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smallFlowEdgesThreshold</td><td>The configurable threshold for detecting the small flow edges </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The indices of the edges crossing small flow edges </dd></dl>

</div>
</div>
<a id="aabbb0f354d3087a90a41934defe7b0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbb0f354d3087a90a41934defe7b0a9">&#9670;&nbsp;</a></span>GetFlowEdgesCenters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structmeshkernel_1_1_point.html">Point</a>&gt; meshkernel::Mesh2D::GetFlowEdgesCenters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the flow edges centers from the crossing edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>The crossing edges indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The centers of the flow edges </dd></dl>

</div>
</div>
<a id="a52d607450f4f095e28da4386939dc1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d607450f4f095e28da4386939dc1ec">&#9670;&nbsp;</a></span>GetHangingEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; meshkernel::Mesh2D::GetHangingEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the hanging edges. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector with the indices of the hanging edges </dd></dl>

</div>
</div>
<a id="aea6575301bc3c4c17e3a76c5efca4ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6575301bc3c4c17e3a76c5efca4ad5">&#9670;&nbsp;</a></span>GetObtuseTrianglesCenters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structmeshkernel_1_1_point.html">Point</a>&gt; meshkernel::Mesh2D::GetObtuseTrianglesCenters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mass centers of obtuse triangles. </p>
<dl class="section return"><dt>Returns</dt><dd>The center of obtuse triangles </dd></dl>

</div>
</div>
<a id="afaa6bfaadd219f15bbb7b45ee696a256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa6bfaadd219f15bbb7b45ee696a256">&#9670;&nbsp;</a></span>GetOrthogonality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; meshkernel::Mesh2D::GetOrthogonality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the orthogonality values, the inner product of edges and segments connecting the face circumcenters. </p>
<dl class="section return"><dt>Returns</dt><dd>The edge orthogonality </dd></dl>

</div>
</div>
<a id="aee516031de33d12a21a5d0aae1007162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee516031de33d12a21a5d0aae1007162">&#9670;&nbsp;</a></span>GetSmoothness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; meshkernel::Mesh2D::GetSmoothness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the smoothness values, ratios of the face areas. </p>
<dl class="section return"><dt>Returns</dt><dd>The smoothness at the edges </dd></dl>

</div>
</div>
<a id="a5dc822de50acdf0f3cb964c1215a960a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc822de50acdf0f3cb964c1215a960a">&#9670;&nbsp;</a></span>IsSegmentCrossingABoundaryEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;size_t, size_t&gt; meshkernel::Mesh2D::IsSegmentCrossingABoundaryEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>firstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>secondPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inquire if a segment is crossing a face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstPoint</td><td>The first point of the segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondPoint</td><td>The second point of the segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple with the intersectedFace face index and intersected edge index </dd></dl>

</div>
</div>
<a id="a40a323c8828549c59994bb20bbc5a7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a323c8828549c59994bb20bbc5a7ab">&#9670;&nbsp;</a></span>MakeDualFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::MakeDualFace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>enlargementFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dualFace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a dual face around the node, enlarged by a factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enlargementFactor</td><td>The factor by which the dual face is enlarged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dualFace</td><td>The dual face to be calculated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf52d4c97ef09036a3110ab61fab031b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf52d4c97ef09036a3110ab61fab031b">&#9670;&nbsp;</a></span>MeshBoundaryToPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structmeshkernel_1_1_point.html">Point</a>&gt; meshkernel::Mesh2D::MeshBoundaryToPolygon </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all mesh boundaries to a vector of polygon nodes, including holes (copynetboundstopol) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The polygon where the operation is performed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting polygon mesh boundary </dd></dl>

</div>
</div>
<a id="a0842f06cb37b04dea67fb797056cd216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0842f06cb37b04dea67fb797056cd216">&#9670;&nbsp;</a></span>NodeMaskFromEdgeMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; meshkernel::Mesh2D::NodeMaskFromEdgeMask </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>edgeMask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From the edge mask compute the node mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeMask</td><td>The edge mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node mask </dd></dl>

</div>
</div>
<a id="adbc47b25ff52ee8fd178b357c7abfe91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc47b25ff52ee8fd178b357c7abfe91">&#9670;&nbsp;</a></span>NodeMaskFromPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; meshkernel::Mesh2D::NodeMaskFromPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inside</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask all nodes included in all polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The input polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inside</td><td>Inside or outside option </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node mask </dd></dl>

</div>
</div>
<a id="a9e874419b2e05ab89e9000f16f3e905b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e874419b2e05ab89e9000f16f3e905b">&#9670;&nbsp;</a></span>OffsetSphericalCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::OffsetSphericalCoordinates </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>miny</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset the x coordinates if m_projection is spherical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minx</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">miny</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97bc195a366c88af68ab87b9d2a5f032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97bc195a366c88af68ab87b9d2a5f032">&#9670;&nbsp;</a></span>PointFaceIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; meshkernel::Mesh2D::PointFaceIndices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a collection of points, compute the face indices including them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>The input point vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face indices including the points. </dd></dl>

</div>
</div>
<a id="a4d5245c9e158f76dfbbd1cf12366cc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5245c9e158f76dfbbd1cf12366cc98">&#9670;&nbsp;</a></span>SortedFacesAroundNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; meshkernel::Mesh2D::SortedFacesAroundNode </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the faces around a node, sorted in counter clock wise order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face indexses </dd></dl>

</div>
</div>
<a id="a8462ca5491385d8351864f36b7dc5e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8462ca5491385d8351864f36b7dc5e99">&#9670;&nbsp;</a></span>WalkBoundaryFromNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::WalkBoundaryFromNode </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygonNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>isVisited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>currentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshBoundaryPolygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a polygon from the meshboundary, by walking through the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygonNodes</td><td>The input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isVisited</td><td>the visited mesh nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currentNode</td><td>the current node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">meshBoundaryPolygon</td><td>The resulting polygon points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/MeshKernel/MeshKernel/include/MeshKernel/<a class="el" href="_mesh2_d_8hpp_source.html">Mesh2D.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
