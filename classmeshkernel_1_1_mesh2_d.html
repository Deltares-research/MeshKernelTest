<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeshKernel: meshkernel::Mesh2D Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MeshKernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemeshkernel.html">meshkernel</a></li><li class="navelem"><a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classmeshkernel_1_1_mesh2_d-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">meshkernel::Mesh2D Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class derived from <a class="el" href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2...">Mesh</a>, which describes unstructures 2d meshes.  
 <a href="classmeshkernel_1_1_mesh2_d.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="include_2_mesh_kernel_2_mesh2_d_8hpp_source.html">Mesh2D.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for meshkernel::Mesh2D:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmeshkernel_1_1_mesh2_d.png" usemap="#meshkernel::Mesh2D_map" alt=""/>
  <map id="meshkernel::Mesh2D_map" name="meshkernel::Mesh2D_map">
<area href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2..." alt="meshkernel::Mesh" shape="rect" coords="0,0,129,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a41e7c8bf5e92fec3f46ba18204e8cc6e"><td class="memItemLeft" align="right" valign="top"><a id="a41e7c8bf5e92fec3f46ba18204e8cc6e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a41e7c8bf5e92fec3f46ba18204e8cc6e">DeleteMeshOptions</a> { <b>AllNodesInside</b> = 0, 
<b>FacesWithIncludedCircumcenters</b> = 1, 
<b>FacesCompletelyIncluded</b> = 2
 }</td></tr>
<tr class="memdesc:a41e7c8bf5e92fec3f46ba18204e8cc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator describing the different options to delete a mesh. <br /></td></tr>
<tr class="separator:a41e7c8bf5e92fec3f46ba18204e8cc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17db40a7b9ea9151e51231c4af416d47"><td class="memItemLeft" align="right" valign="top"><a id="a17db40a7b9ea9151e51231c4af416d47"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a17db40a7b9ea9151e51231c4af416d47">NodeTypes</a> { <br />
&#160;&#160;<b>internalNode</b>, 
<b>onRing</b>, 
<b>cornerNode</b>, 
<b>hangingNode</b>, 
<br />
&#160;&#160;<b>other</b>
<br />
 }</td></tr>
<tr class="memdesc:a17db40a7b9ea9151e51231c4af416d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator describing the different node types. <br /></td></tr>
<tr class="separator:a17db40a7b9ea9151e51231c4af416d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:a2bdcf8039b306fc22ee56210ac137078 inherit pub_types_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078">Type</a> { <a class="el" href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078a1e137f21a2ff25f665e60ff9b84768dc">Type::Mesh1D</a>, 
<a class="el" href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078ac2a2ccf2a6184eaa7693608895d88d13">Type::Mesh2D</a>
 }</td></tr>
<tr class="memdesc:a2bdcf8039b306fc22ee56210ac137078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator describing the different mesh types.  <a href="classmeshkernel_1_1_mesh.html#a2bdcf8039b306fc22ee56210ac137078">More...</a><br /></td></tr>
<tr class="separator:a2bdcf8039b306fc22ee56210ac137078 inherit pub_types_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197164c7734986c1409935442b520f63 inherit pub_types_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a197164c7734986c1409935442b520f63">Location</a> { <a class="el" href="classmeshkernel_1_1_mesh.html#a197164c7734986c1409935442b520f63a4f93ea0836ba76b6f9b81e3eee53a3af">Location::Faces</a> = 0, 
<a class="el" href="classmeshkernel_1_1_mesh.html#a197164c7734986c1409935442b520f63a187c6ad3a74cc93ac6c2229d398e383e">Location::Nodes</a> = 1, 
<a class="el" href="classmeshkernel_1_1_mesh.html#a197164c7734986c1409935442b520f63a484afb8d54ec549700b1fe96417519a9">Location::Edges</a> = 2, 
<a class="el" href="classmeshkernel_1_1_mesh.html#a197164c7734986c1409935442b520f63a88183b946cc5f0e8c96b2e66e1c74a7e">Location::Unknown</a> = 3
 }</td></tr>
<tr class="memdesc:a197164c7734986c1409935442b520f63"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2...">Mesh</a> locations enumeration.  <a href="classmeshkernel_1_1_mesh.html#a197164c7734986c1409935442b520f63">More...</a><br /></td></tr>
<tr class="separator:a197164c7734986c1409935442b520f63 inherit pub_types_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9194a3e8f0ac27124390ed34a8f29ef8"><td class="memItemLeft" align="right" valign="top"><a id="a9194a3e8f0ac27124390ed34a8f29ef8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a9194a3e8f0ac27124390ed34a8f29ef8">Mesh2D</a> ()=default</td></tr>
<tr class="memdesc:a9194a3e8f0ac27124390ed34a8f29ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a9194a3e8f0ac27124390ed34a8f29ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab971b113521125e64ab3218bcfdaadef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ab971b113521125e64ab3218bcfdaadef">Mesh2D</a> (<a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:ab971b113521125e64ab3218bcfdaadef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh2d using only the projection.  <a href="classmeshkernel_1_1_mesh2_d.html#ab971b113521125e64ab3218bcfdaadef">More...</a><br /></td></tr>
<tr class="separator:ab971b113521125e64ab3218bcfdaadef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac667a2395d4b205d7c4be2536bc301eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ac667a2395d4b205d7c4be2536bc301eb">Mesh2D</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;edges, const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:ac667a2395d4b205d7c4be2536bc301eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh2d starting from the edges and nodes.  <a href="classmeshkernel_1_1_mesh2_d.html#ac667a2395d4b205d7c4be2536bc301eb">More...</a><br /></td></tr>
<tr class="separator:ac667a2395d4b205d7c4be2536bc301eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f666425d7520ef162b4c546cc8b59a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ae3f666425d7520ef162b4c546cc8b59a">Mesh2D</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;edges, const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, const std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&gt; &amp;faceNodes, const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;numFaceNodes, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:ae3f666425d7520ef162b4c546cc8b59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh2d from face nodes and num face nodes.  <a href="classmeshkernel_1_1_mesh2_d.html#ae3f666425d7520ef162b4c546cc8b59a">More...</a><br /></td></tr>
<tr class="separator:ae3f666425d7520ef162b4c546cc8b59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae466a7ef61c51eb720f50d31ed94ca1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aae466a7ef61c51eb720f50d31ed94ca1">Mesh2D</a> (const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:aae466a7ef61c51eb720f50d31ed94ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create triangular grid from nodes (triangulatesamplestonetwork)  <a href="classmeshkernel_1_1_mesh2_d.html#aae466a7ef61c51eb720f50d31ed94ca1">More...</a><br /></td></tr>
<tr class="separator:aae466a7ef61c51eb720f50d31ed94ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19223d2ef844428f5858291f588ad47"><td class="memItemLeft" align="right" valign="top"><a id="af19223d2ef844428f5858291f588ad47"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#af19223d2ef844428f5858291f588ad47">Administrate</a> () override</td></tr>
<tr class="memdesc:af19223d2ef844428f5858291f588ad47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform complete administration. <br /></td></tr>
<tr class="separator:af19223d2ef844428f5858291f588ad47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf625bb91c465cf93bfed19ce43dad50"><td class="memItemLeft" align="right" valign="top"><a id="aaf625bb91c465cf93bfed19ce43dad50"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aaf625bb91c465cf93bfed19ce43dad50">ComputeCircumcentersMassCentersAndFaceAreas</a> (bool computeMassCenters=false)</td></tr>
<tr class="memdesc:aaf625bb91c465cf93bfed19ce43dad50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute face circumcenters. <br /></td></tr>
<tr class="separator:aaf625bb91c465cf93bfed19ce43dad50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b94a7acb30a64061a8767efec60811b"><td class="memItemLeft" align="right" valign="top"><a id="a5b94a7acb30a64061a8767efec60811b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a5b94a7acb30a64061a8767efec60811b">FindFaces</a> ()</td></tr>
<tr class="memdesc:a5b94a7acb30a64061a8767efec60811b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find faces: constructs the m_facesNodes mapping, face mass centers and areas (findcells) <br /></td></tr>
<tr class="separator:a5b94a7acb30a64061a8767efec60811b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e874419b2e05ab89e9000f16f3e905b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a9e874419b2e05ab89e9000f16f3e905b">OffsetSphericalCoordinates</a> (double minx, double miny)</td></tr>
<tr class="memdesc:a9e874419b2e05ab89e9000f16f3e905b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset the x coordinates if m_projection is spherical.  <a href="classmeshkernel_1_1_mesh2_d.html#a9e874419b2e05ab89e9000f16f3e905b">More...</a><br /></td></tr>
<tr class="separator:a9e874419b2e05ab89e9000f16f3e905b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35186078240ebfeac3c6bf9db8160cd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a35186078240ebfeac3c6bf9db8160cd2">ComputeFaceClosedPolygonWithLocalMappings</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceIndex, std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygonNodesCache, std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;localNodeIndicesCache, std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;globalEdgeIndicesCache) const</td></tr>
<tr class="memdesc:a35186078240ebfeac3c6bf9db8160cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a face create a closed polygon and fill local mapping caches (get_cellpolygon)  <a href="classmeshkernel_1_1_mesh2_d.html#a35186078240ebfeac3c6bf9db8160cd2">More...</a><br /></td></tr>
<tr class="separator:a35186078240ebfeac3c6bf9db8160cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbc0d31cca18d130630e3ed8fa653ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#abdbc0d31cca18d130630e3ed8fa653ff">ComputeFaceClosedPolygon</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceIndex, std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygonNodesCache) const</td></tr>
<tr class="memdesc:abdbc0d31cca18d130630e3ed8fa653ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a face create a closed polygon.  <a href="classmeshkernel_1_1_mesh2_d.html#abdbc0d31cca18d130630e3ed8fa653ff">More...</a><br /></td></tr>
<tr class="separator:abdbc0d31cca18d130630e3ed8fa653ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4383fa3d1ca1d1aed4405a629330f4a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmeshkernel_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a4383fa3d1ca1d1aed4405a629330f4a1">ComputeFaceCircumenter</a> (std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygon, const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;edgesNumFaces) const</td></tr>
<tr class="memdesc:a4383fa3d1ca1d1aed4405a629330f4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a closed polygon, compute the circumcenter of a face (getcircumcenter)  <a href="classmeshkernel_1_1_mesh2_d.html#a4383fa3d1ca1d1aed4405a629330f4a1">More...</a><br /></td></tr>
<tr class="separator:a4383fa3d1ca1d1aed4405a629330f4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6575301bc3c4c17e3a76c5efca4ad5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aea6575301bc3c4c17e3a76c5efca4ad5">GetObtuseTrianglesCenters</a> ()</td></tr>
<tr class="memdesc:aea6575301bc3c4c17e3a76c5efca4ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mass centers of obtuse triangles.  <a href="classmeshkernel_1_1_mesh2_d.html#aea6575301bc3c4c17e3a76c5efca4ad5">More...</a><br /></td></tr>
<tr class="separator:aea6575301bc3c4c17e3a76c5efca4ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a40ea7da15823130792bcb0d74214a2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a6a40ea7da15823130792bcb0d74214a2">GetEdgesCrossingSmallFlowEdges</a> (double smallFlowEdgesThreshold)</td></tr>
<tr class="memdesc:a6a40ea7da15823130792bcb0d74214a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the edges crossing the small flow edges.  <a href="classmeshkernel_1_1_mesh2_d.html#a6a40ea7da15823130792bcb0d74214a2">More...</a><br /></td></tr>
<tr class="separator:a6a40ea7da15823130792bcb0d74214a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5a26d4f62a3ef41c124b87cfbb7bae"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#acd5a26d4f62a3ef41c124b87cfbb7bae">GetFlowEdgesCenters</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;edges) const</td></tr>
<tr class="memdesc:acd5a26d4f62a3ef41c124b87cfbb7bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the flow edges centers from the crossing edges.  <a href="classmeshkernel_1_1_mesh2_d.html#acd5a26d4f62a3ef41c124b87cfbb7bae">More...</a><br /></td></tr>
<tr class="separator:acd5a26d4f62a3ef41c124b87cfbb7bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6855534ffcff0ca5ac4ce4e1bc4ca229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a6855534ffcff0ca5ac4ce4e1bc4ca229">DeleteSmallFlowEdges</a> (double smallFlowEdgesThreshold)</td></tr>
<tr class="memdesc:a6855534ffcff0ca5ac4ce4e1bc4ca229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes small flow edges (removesmallflowlinks, part 1)  <a href="classmeshkernel_1_1_mesh2_d.html#a6855534ffcff0ca5ac4ce4e1bc4ca229">More...</a><br /></td></tr>
<tr class="separator:a6855534ffcff0ca5ac4ce4e1bc4ca229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03d80377cafe9fdfb22545423fb8fa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#af03d80377cafe9fdfb22545423fb8fa6">DeleteSmallTrianglesAtBoundaries</a> (double minFractionalAreaTriangles)</td></tr>
<tr class="memdesc:af03d80377cafe9fdfb22545423fb8fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes small triangles at the boundaries (removesmallflowlinks, part 2)  <a href="classmeshkernel_1_1_mesh2_d.html#af03d80377cafe9fdfb22545423fb8fa6">More...</a><br /></td></tr>
<tr class="separator:af03d80377cafe9fdfb22545423fb8fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ba61b67bf1c9b93d8f37124935545b"><td class="memItemLeft" align="right" valign="top"><a id="a43ba61b67bf1c9b93d8f37124935545b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a43ba61b67bf1c9b93d8f37124935545b">ComputeNodeNeighbours</a> ()</td></tr>
<tr class="memdesc:a43ba61b67bf1c9b93d8f37124935545b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes m_nodesNodes, see class members. <br /></td></tr>
<tr class="separator:a43ba61b67bf1c9b93d8f37124935545b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa6bfaadd219f15bbb7b45ee696a256"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#afaa6bfaadd219f15bbb7b45ee696a256">GetOrthogonality</a> ()</td></tr>
<tr class="memdesc:afaa6bfaadd219f15bbb7b45ee696a256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the orthogonality values, the inner product of edges and segments connecting the face circumcenters.  <a href="classmeshkernel_1_1_mesh2_d.html#afaa6bfaadd219f15bbb7b45ee696a256">More...</a><br /></td></tr>
<tr class="separator:afaa6bfaadd219f15bbb7b45ee696a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee516031de33d12a21a5d0aae1007162"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#aee516031de33d12a21a5d0aae1007162">GetSmoothness</a> ()</td></tr>
<tr class="memdesc:aee516031de33d12a21a5d0aae1007162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the smoothness values, ratios of the face areas.  <a href="classmeshkernel_1_1_mesh2_d.html#aee516031de33d12a21a5d0aae1007162">More...</a><br /></td></tr>
<tr class="separator:aee516031de33d12a21a5d0aae1007162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281602c3eee4a57f2f06a89badafa04d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a281602c3eee4a57f2f06a89badafa04d">ComputeAspectRatios</a> (std::vector&lt; double &gt; &amp;aspectRatios)</td></tr>
<tr class="memdesc:a281602c3eee4a57f2f06a89badafa04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the aspect ratios (the ratios edges lengths to flow edges lengths)  <a href="classmeshkernel_1_1_mesh2_d.html#a281602c3eee4a57f2f06a89badafa04d">More...</a><br /></td></tr>
<tr class="separator:a281602c3eee4a57f2f06a89badafa04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70f0bfaf5a55b9b0a76bd6a3d98041f"><td class="memItemLeft" align="right" valign="top"><a id="ae70f0bfaf5a55b9b0a76bd6a3d98041f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ae70f0bfaf5a55b9b0a76bd6a3d98041f">ClassifyNodes</a> ()</td></tr>
<tr class="memdesc:ae70f0bfaf5a55b9b0a76bd6a3d98041f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classifies the nodes (makenetnodescoding) <br /></td></tr>
<tr class="separator:ae70f0bfaf5a55b9b0a76bd6a3d98041f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aadc845f5afa2319c01fb984288e3de"><td class="memItemLeft" align="right" valign="top"><a id="a9aadc845f5afa2319c01fb984288e3de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a9aadc845f5afa2319c01fb984288e3de">DeleteDegeneratedTriangles</a> ()</td></tr>
<tr class="memdesc:a9aadc845f5afa2319c01fb984288e3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes coinciding triangles. <br /></td></tr>
<tr class="separator:a9aadc845f5afa2319c01fb984288e3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4836ba2335da505e7c952bbc8706873b"><td class="memItemLeft" align="right" valign="top"><a id="a4836ba2335da505e7c952bbc8706873b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a4836ba2335da505e7c952bbc8706873b">TriangulateFaces</a> ()</td></tr>
<tr class="memdesc:a4836ba2335da505e7c952bbc8706873b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform non-triangular faces in triangular faces. <br /></td></tr>
<tr class="separator:a4836ba2335da505e7c952bbc8706873b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acdab15ff562599311e2264f4728844"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a1acdab15ff562599311e2264f4728844">MakeDualFace</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> node, double enlargementFactor, std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;dualFace)</td></tr>
<tr class="memdesc:a1acdab15ff562599311e2264f4728844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a dual face around the node, enlarged by a factor.  <a href="classmeshkernel_1_1_mesh2_d.html#a1acdab15ff562599311e2264f4728844">More...</a><br /></td></tr>
<tr class="separator:a1acdab15ff562599311e2264f4728844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1a11d73e8a0c2974e5cd00d628f584"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#afa1a11d73e8a0c2974e5cd00d628f584">SortedFacesAroundNode</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> node) const</td></tr>
<tr class="memdesc:afa1a11d73e8a0c2974e5cd00d628f584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the faces around a node, sorted in counter clock wise order.  <a href="classmeshkernel_1_1_mesh2_d.html#afa1a11d73e8a0c2974e5cd00d628f584">More...</a><br /></td></tr>
<tr class="separator:afa1a11d73e8a0c2974e5cd00d628f584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf52d4c97ef09036a3110ab61fab031b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#acf52d4c97ef09036a3110ab61fab031b">MeshBoundaryToPolygon</a> (const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;polygon)</td></tr>
<tr class="memdesc:acf52d4c97ef09036a3110ab61fab031b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all mesh boundaries to a vector of polygon nodes, including holes (copynetboundstopol)  <a href="classmeshkernel_1_1_mesh2_d.html#acf52d4c97ef09036a3110ab61fab031b">More...</a><br /></td></tr>
<tr class="separator:acf52d4c97ef09036a3110ab61fab031b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccf24cf23136393e36d0fd07bbbfff2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a9ccf24cf23136393e36d0fd07bbbfff2">WalkBoundaryFromNode</a> (const <a class="el" href="classmeshkernel_1_1_polygon.html">Polygon</a> &amp;polygon, std::vector&lt; bool &gt; &amp;isVisited, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &amp;currentNode, std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;meshBoundaryPolygon) const</td></tr>
<tr class="memdesc:a9ccf24cf23136393e36d0fd07bbbfff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a polygon from the meshboundary, by walking through the mesh.  <a href="classmeshkernel_1_1_mesh2_d.html#a9ccf24cf23136393e36d0fd07bbbfff2">More...</a><br /></td></tr>
<tr class="separator:a9ccf24cf23136393e36d0fd07bbbfff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54988d04981fbfcc21077fbd44229910"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a54988d04981fbfcc21077fbd44229910">GetHangingEdges</a> () const</td></tr>
<tr class="memdesc:a54988d04981fbfcc21077fbd44229910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the hanging edges.  <a href="classmeshkernel_1_1_mesh2_d.html#a54988d04981fbfcc21077fbd44229910">More...</a><br /></td></tr>
<tr class="separator:a54988d04981fbfcc21077fbd44229910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f04f13e20376dd7fccb5eb6c2c82ef"><td class="memItemLeft" align="right" valign="top"><a id="a61f04f13e20376dd7fccb5eb6c2c82ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a61f04f13e20376dd7fccb5eb6c2c82ef">DeleteHangingEdges</a> ()</td></tr>
<tr class="memdesc:a61f04f13e20376dd7fccb5eb6c2c82ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the hanging edges. <br /></td></tr>
<tr class="separator:a61f04f13e20376dd7fccb5eb6c2c82ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad446a7de6ca7ea10fa864ef35e02c3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a9ad446a7de6ca7ea10fa864ef35e02c3">PointFaceIndices</a> (const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;points)</td></tr>
<tr class="memdesc:a9ad446a7de6ca7ea10fa864ef35e02c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a collection of points, compute the face indices including them.  <a href="classmeshkernel_1_1_mesh2_d.html#a9ad446a7de6ca7ea10fa864ef35e02c3">More...</a><br /></td></tr>
<tr class="separator:a9ad446a7de6ca7ea10fa864ef35e02c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cce62a059fa51a0c94b52f33a456eed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a6cce62a059fa51a0c94b52f33a456eed">DeleteMesh</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygon, int deletionOption, bool invertDeletion)</td></tr>
<tr class="memdesc:a6cce62a059fa51a0c94b52f33a456eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a mesh in a polygon, using several options (delnet)  <a href="classmeshkernel_1_1_mesh2_d.html#a6cce62a059fa51a0c94b52f33a456eed">More...</a><br /></td></tr>
<tr class="separator:a6cce62a059fa51a0c94b52f33a456eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7e8009c8aebe6d3d8420be59d7b882"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a8e7e8009c8aebe6d3d8420be59d7b882">IsSegmentCrossingABoundaryEdge</a> (const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;firstPoint, const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;secondPoint) const</td></tr>
<tr class="memdesc:a8e7e8009c8aebe6d3d8420be59d7b882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if a segment is crossing a face.  <a href="classmeshkernel_1_1_mesh2_d.html#a8e7e8009c8aebe6d3d8420be59d7b882">More...</a><br /></td></tr>
<tr class="separator:a8e7e8009c8aebe6d3d8420be59d7b882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2aca39594f2a68e3717829f98ba04d0"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; <a class="el" href="structmeshkernel_1_1_mesh_1_1_edge_mesh_polyline_intersection.html">EdgeMeshPolylineIntersection</a> &gt;, std::vector&lt; <a class="el" href="structmeshkernel_1_1_mesh_1_1_face_mesh_polyline_intersection.html">FaceMeshPolylineIntersection</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#ad2aca39594f2a68e3717829f98ba04d0">GetPolylineIntersections</a> (const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;polyLine)</td></tr>
<tr class="memdesc:ad2aca39594f2a68e3717829f98ba04d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the edges and faces intersected by a polyline, with additional information on the intersections.  <a href="classmeshkernel_1_1_mesh2_d.html#ad2aca39594f2a68e3717829f98ba04d0">More...</a><br /></td></tr>
<tr class="separator:ad2aca39594f2a68e3717829f98ba04d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7decde6c1988555f70610c313e68342a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a7decde6c1988555f70610c313e68342a">MaskEdgesOfFacesInPolygon</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, bool invertSelection, bool includeIntersected) const</td></tr>
<tr class="memdesc:a7decde6c1988555f70610c313e68342a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masks the edges of all faces entirely included in all polygons.  <a href="classmeshkernel_1_1_mesh2_d.html#a7decde6c1988555f70610c313e68342a">More...</a><br /></td></tr>
<tr class="separator:a7decde6c1988555f70610c313e68342a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0842f06cb37b04dea67fb797056cd216"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a0842f06cb37b04dea67fb797056cd216">NodeMaskFromEdgeMask</a> (std::vector&lt; int &gt; const &amp;edgeMask) const</td></tr>
<tr class="memdesc:a0842f06cb37b04dea67fb797056cd216"><td class="mdescLeft">&#160;</td><td class="mdescRight">From the edge mask compute the node mask.  <a href="classmeshkernel_1_1_mesh2_d.html#a0842f06cb37b04dea67fb797056cd216">More...</a><br /></td></tr>
<tr class="separator:a0842f06cb37b04dea67fb797056cd216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc47b25ff52ee8fd178b357c7abfe91"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#adbc47b25ff52ee8fd178b357c7abfe91">NodeMaskFromPolygon</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, bool inside) const</td></tr>
<tr class="memdesc:adbc47b25ff52ee8fd178b357c7abfe91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask all nodes included in all polygons.  <a href="classmeshkernel_1_1_mesh2_d.html#adbc47b25ff52ee8fd178b357c7abfe91">More...</a><br /></td></tr>
<tr class="separator:adbc47b25ff52ee8fd178b357c7abfe91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db6fe647045d8c4fe81e44b1dcb7125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a4db6fe647045d8c4fe81e44b1dcb7125">FindOppositeEdge</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceId, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId) const</td></tr>
<tr class="memdesc:a4db6fe647045d8c4fe81e44b1dcb7125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find edge on the opposite side of the element.  <a href="classmeshkernel_1_1_mesh2_d.html#a4db6fe647045d8c4fe81e44b1dcb7125">More...</a><br /></td></tr>
<tr class="separator:a4db6fe647045d8c4fe81e44b1dcb7125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399739726d1d913f8b23a385abe536aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a399739726d1d913f8b23a385abe536aa">NextFace</a> (const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceId, const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeId) const</td></tr>
<tr class="memdesc:a399739726d1d913f8b23a385abe536aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next face adjacent to the edge on the opposite side.  <a href="classmeshkernel_1_1_mesh2_d.html#a399739726d1d913f8b23a385abe536aa">More...</a><br /></td></tr>
<tr class="separator:a399739726d1d913f8b23a385abe536aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:a05bc04f7af254a40598f8b9627da6e60 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a05bc04f7af254a40598f8b9627da6e60"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a05bc04f7af254a40598f8b9627da6e60">Mesh</a> ()=default</td></tr>
<tr class="memdesc:a05bc04f7af254a40598f8b9627da6e60 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a05bc04f7af254a40598f8b9627da6e60 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b01249e9753c76d0ec3942bd5027105 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a6b01249e9753c76d0ec3942bd5027105">Mesh</a> (<a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:a6b01249e9753c76d0ec3942bd5027105 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty mesh, sets only the projection.  <a href="classmeshkernel_1_1_mesh.html#a6b01249e9753c76d0ec3942bd5027105">More...</a><br /></td></tr>
<tr class="separator:a6b01249e9753c76d0ec3942bd5027105 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a21a6199afcf9444f0e7ae17856dcf inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a77a21a6199afcf9444f0e7ae17856dcf">Mesh</a> (const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;edges, const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;nodes, <a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a> projection)</td></tr>
<tr class="memdesc:a77a21a6199afcf9444f0e7ae17856dcf inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh starting from the edges and nodes.  <a href="classmeshkernel_1_1_mesh.html#a77a21a6199afcf9444f0e7ae17856dcf">More...</a><br /></td></tr>
<tr class="separator:a77a21a6199afcf9444f0e7ae17856dcf inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557891a65132f1629578381c377fafb7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a557891a65132f1629578381c377fafb7">IsNodeOnBoundary</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> node) const</td></tr>
<tr class="memdesc:a557891a65132f1629578381c377fafb7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if a node is on boundary.  <a href="classmeshkernel_1_1_mesh.html#a557891a65132f1629578381c377fafb7">More...</a><br /></td></tr>
<tr class="separator:a557891a65132f1629578381c377fafb7 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdde73c3f0dd734948065fc83bb7a61 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aacdde73c3f0dd734948065fc83bb7a61">GetNumNodes</a> () const</td></tr>
<tr class="memdesc:aacdde73c3f0dd734948065fc83bb7a61 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid nodes.  <a href="classmeshkernel_1_1_mesh.html#aacdde73c3f0dd734948065fc83bb7a61">More...</a><br /></td></tr>
<tr class="separator:aacdde73c3f0dd734948065fc83bb7a61 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5150280bdba56884de15211a34e64155 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5150280bdba56884de15211a34e64155">GetNumEdges</a> () const</td></tr>
<tr class="memdesc:a5150280bdba56884de15211a34e64155 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid edges.  <a href="classmeshkernel_1_1_mesh.html#a5150280bdba56884de15211a34e64155">More...</a><br /></td></tr>
<tr class="separator:a5150280bdba56884de15211a34e64155 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50abbc0382968330e4a530e84f093194 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a50abbc0382968330e4a530e84f093194">GetNumFaces</a> () const</td></tr>
<tr class="memdesc:a50abbc0382968330e4a530e84f093194 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid faces.  <a href="classmeshkernel_1_1_mesh.html#a50abbc0382968330e4a530e84f093194">More...</a><br /></td></tr>
<tr class="separator:a50abbc0382968330e4a530e84f093194 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca36da6ddea6ea4112324aa175820703 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aca36da6ddea6ea4112324aa175820703">GetNumFaceEdges</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> faceIndex) const</td></tr>
<tr class="memdesc:aca36da6ddea6ea4112324aa175820703 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges for a face.  <a href="classmeshkernel_1_1_mesh.html#aca36da6ddea6ea4112324aa175820703">More...</a><br /></td></tr>
<tr class="separator:aca36da6ddea6ea4112324aa175820703 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a524e94ec09b4464618a6e4f060bb2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a37a524e94ec09b4464618a6e4f060bb2">GetNumEdgesFaces</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edgeIndex) const</td></tr>
<tr class="memdesc:a37a524e94ec09b4464618a6e4f060bb2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of faces an edges shares.  <a href="classmeshkernel_1_1_mesh.html#a37a524e94ec09b4464618a6e4f060bb2">More...</a><br /></td></tr>
<tr class="separator:a37a524e94ec09b4464618a6e4f060bb2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569153beacd2187549c3cdf56141a41 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a7569153beacd2187549c3cdf56141a41">IsEdgeOnBoundary</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edge) const</td></tr>
<tr class="memdesc:a7569153beacd2187549c3cdf56141a41 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if an edge is on boundary.  <a href="classmeshkernel_1_1_mesh.html#a7569153beacd2187549c3cdf56141a41">More...</a><br /></td></tr>
<tr class="separator:a7569153beacd2187549c3cdf56141a41 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59544d3cee42126f27bed0da80518051 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a59544d3cee42126f27bed0da80518051">IsFaceOnBoundary</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> face) const</td></tr>
<tr class="memdesc:a59544d3cee42126f27bed0da80518051 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire if a face is on boundary.  <a href="classmeshkernel_1_1_mesh.html#a59544d3cee42126f27bed0da80518051">More...</a><br /></td></tr>
<tr class="separator:a59544d3cee42126f27bed0da80518051 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b046d2ada644ab4b7109d756bbc14be inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a3b046d2ada644ab4b7109d756bbc14be">MergeTwoNodes</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> startNode, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> endNode)</td></tr>
<tr class="memdesc:a3b046d2ada644ab4b7109d756bbc14be inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two mesh nodes.  <a href="classmeshkernel_1_1_mesh.html#a3b046d2ada644ab4b7109d756bbc14be">More...</a><br /></td></tr>
<tr class="separator:a3b046d2ada644ab4b7109d756bbc14be inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c62be0cf9f5bf96f52c19f0e420dd80 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a6c62be0cf9f5bf96f52c19f0e420dd80">MergeNodesInPolygon</a> (const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;polygons, double mergingDistance)</td></tr>
<tr class="memdesc:a6c62be0cf9f5bf96f52c19f0e420dd80 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge close mesh nodes inside a polygon (MERGENODESINPOLYGON)  <a href="classmeshkernel_1_1_mesh.html#a6c62be0cf9f5bf96f52c19f0e420dd80">More...</a><br /></td></tr>
<tr class="separator:a6c62be0cf9f5bf96f52c19f0e420dd80 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5991f06852a3cc289a8e821677a850 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aff5991f06852a3cc289a8e821677a850">ConnectNodes</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> startNode, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> endNode)</td></tr>
<tr class="memdesc:aff5991f06852a3cc289a8e821677a850 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect two existing nodes, forming a new edge (connectdbn)  <a href="classmeshkernel_1_1_mesh.html#aff5991f06852a3cc289a8e821677a850">More...</a><br /></td></tr>
<tr class="separator:aff5991f06852a3cc289a8e821677a850 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac817e8abc712be8f0775644a5e7d876d inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ac817e8abc712be8f0775644a5e7d876d">InsertNode</a> (const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;newPoint)</td></tr>
<tr class="memdesc:ac817e8abc712be8f0775644a5e7d876d inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new node in the mesh (setnewpoint)  <a href="classmeshkernel_1_1_mesh.html#ac817e8abc712be8f0775644a5e7d876d">More...</a><br /></td></tr>
<tr class="separator:ac817e8abc712be8f0775644a5e7d876d inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed1d0180239dc2037cd07fe85902aef inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a4ed1d0180239dc2037cd07fe85902aef">DeleteNode</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> node)</td></tr>
<tr class="memdesc:a4ed1d0180239dc2037cd07fe85902aef inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a node.  <a href="classmeshkernel_1_1_mesh.html#a4ed1d0180239dc2037cd07fe85902aef">More...</a><br /></td></tr>
<tr class="separator:a4ed1d0180239dc2037cd07fe85902aef inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca9e46fe37ed14e5b42ca498c8f9c42 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#adca9e46fe37ed14e5b42ca498c8f9c42">FindEdge</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> firstNodeIndex, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> secondNodeIndex) const</td></tr>
<tr class="memdesc:adca9e46fe37ed14e5b42ca498c8f9c42 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the edge sharing two nodes.  <a href="classmeshkernel_1_1_mesh.html#adca9e46fe37ed14e5b42ca498c8f9c42">More...</a><br /></td></tr>
<tr class="separator:adca9e46fe37ed14e5b42ca498c8f9c42 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1250bd9e3a8451cbc273c1a76946c25a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a1250bd9e3a8451cbc273c1a76946c25a">MoveNode</a> (<a class="el" href="classmeshkernel_1_1_point.html">Point</a> newPoint, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> nodeindex)</td></tr>
<tr class="memdesc:a1250bd9e3a8451cbc273c1a76946c25a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a node to a new location.  <a href="classmeshkernel_1_1_mesh.html#a1250bd9e3a8451cbc273c1a76946c25a">More...</a><br /></td></tr>
<tr class="separator:a1250bd9e3a8451cbc273c1a76946c25a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d48ad6ced893499b79a99f076a6fc9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a80d48ad6ced893499b79a99f076a6fc9">FindNodeCloseToAPoint</a> (<a class="el" href="classmeshkernel_1_1_point.html">Point</a> point, const std::vector&lt; bool &gt; &amp;nodeMask)</td></tr>
<tr class="memdesc:a80d48ad6ced893499b79a99f076a6fc9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a node close to a point.  <a href="classmeshkernel_1_1_mesh.html#a80d48ad6ced893499b79a99f076a6fc9">More...</a><br /></td></tr>
<tr class="separator:a80d48ad6ced893499b79a99f076a6fc9 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d72c761ca10c957623ab8b7c98e20a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a42d72c761ca10c957623ab8b7c98e20a">FindNodeCloseToAPoint</a> (<a class="el" href="classmeshkernel_1_1_point.html">Point</a> const &amp;point, double searchRadius)</td></tr>
<tr class="memdesc:a42d72c761ca10c957623ab8b7c98e20a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a node close to a point.  <a href="classmeshkernel_1_1_mesh.html#a42d72c761ca10c957623ab8b7c98e20a">More...</a><br /></td></tr>
<tr class="separator:a42d72c761ca10c957623ab8b7c98e20a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5810ef8ef2bf0707d27f37119e3fe87 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ac5810ef8ef2bf0707d27f37119e3fe87">FindEdgeCloseToAPoint</a> (<a class="el" href="classmeshkernel_1_1_point.html">Point</a> point)</td></tr>
<tr class="separator:ac5810ef8ef2bf0707d27f37119e3fe87 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d2841a4812be93a2ce538358875e84 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a10d2841a4812be93a2ce538358875e84">DeleteEdge</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> edge)</td></tr>
<tr class="memdesc:a10d2841a4812be93a2ce538358875e84 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes an edge.  <a href="classmeshkernel_1_1_mesh.html#a10d2841a4812be93a2ce538358875e84">More...</a><br /></td></tr>
<tr class="separator:a10d2841a4812be93a2ce538358875e84 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a3ba1a2f8974d7367680ea71a70b28 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a86a3ba1a2f8974d7367680ea71a70b28">FindCommonNode</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> firstEdgeIndex, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> secondEdgeIndex) const</td></tr>
<tr class="memdesc:a86a3ba1a2f8974d7367680ea71a70b28 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the common node two edges share This method uses return parameters since the success is evaluated in a hot loop.  <a href="classmeshkernel_1_1_mesh.html#a86a3ba1a2f8974d7367680ea71a70b28">More...</a><br /></td></tr>
<tr class="separator:a86a3ba1a2f8974d7367680ea71a70b28 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d007633404f80e3fb1f2e789bc2859f inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a2d007633404f80e3fb1f2e789bc2859f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a2d007633404f80e3fb1f2e789bc2859f">ComputeEdgesLengths</a> ()</td></tr>
<tr class="memdesc:a2d007633404f80e3fb1f2e789bc2859f inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the lengths of all edges in one go. <br /></td></tr>
<tr class="separator:a2d007633404f80e3fb1f2e789bc2859f inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b2912121a8b224b96f3f8e15397884 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a48b2912121a8b224b96f3f8e15397884"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a48b2912121a8b224b96f3f8e15397884">ComputeEdgesCenters</a> ()</td></tr>
<tr class="memdesc:a48b2912121a8b224b96f3f8e15397884 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the edges centers in one go. <br /></td></tr>
<tr class="separator:a48b2912121a8b224b96f3f8e15397884 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacff872b8bcecdedf5e67af403e8fbe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#adacff872b8bcecdedf5e67af403e8fbe">NodeAdministration</a> ()</td></tr>
<tr class="memdesc:adacff872b8bcecdedf5e67af403e8fbe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node administration (setnodadmin)  <a href="classmeshkernel_1_1_mesh.html#adacff872b8bcecdedf5e67af403e8fbe">More...</a><br /></td></tr>
<tr class="separator:adacff872b8bcecdedf5e67af403e8fbe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadf16bf95337fec05384a2dc07798fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="adadf16bf95337fec05384a2dc07798fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#adadf16bf95337fec05384a2dc07798fe">DeleteInvalidNodesAndEdges</a> ()</td></tr>
<tr class="memdesc:adadf16bf95337fec05384a2dc07798fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all invalid nodes and edges. <br /></td></tr>
<tr class="separator:adadf16bf95337fec05384a2dc07798fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2c7373bafa1d4429c330876f445993 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a4f2c7373bafa1d4429c330876f445993"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a4f2c7373bafa1d4429c330876f445993">AdministrateNodesEdges</a> ()</td></tr>
<tr class="memdesc:a4f2c7373bafa1d4429c330876f445993 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform node and edges administration. <br /></td></tr>
<tr class="separator:a4f2c7373bafa1d4429c330876f445993 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf79b4b9e80ce47284a4cb1d866790a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#accf79b4b9e80ce47284a4cb1d866790a">SortEdgesInCounterClockWiseOrder</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> startNode, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> endNode)</td></tr>
<tr class="memdesc:accf79b4b9e80ce47284a4cb1d866790a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort mesh edges around a node in counterclockwise order (Sort_links_ccw)  <a href="classmeshkernel_1_1_mesh.html#accf79b4b9e80ce47284a4cb1d866790a">More...</a><br /></td></tr>
<tr class="separator:accf79b4b9e80ce47284a4cb1d866790a inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1805fbb756c7f015c609eda23a3d4b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#afe1805fbb756c7f015c609eda23a3d4b">ComputeMaxLengthSurroundingEdges</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> node)</td></tr>
<tr class="memdesc:afe1805fbb756c7f015c609eda23a3d4b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the max length of the edges connected to a node.  <a href="classmeshkernel_1_1_mesh.html#afe1805fbb756c7f015c609eda23a3d4b">More...</a><br /></td></tr>
<tr class="separator:afe1805fbb756c7f015c609eda23a3d4b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb284547a7588c325732c913bda14d2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#adfb284547a7588c325732c913bda14d2">BuildTree</a> (<a class="el" href="classmeshkernel_1_1_mesh.html#a197164c7734986c1409935442b520f63">Location</a> meshLocation)</td></tr>
<tr class="memdesc:adfb284547a7588c325732c913bda14d2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the rtree for the corresponding location, using all locations.  <a href="classmeshkernel_1_1_mesh.html#adfb284547a7588c325732c913bda14d2">More...</a><br /></td></tr>
<tr class="separator:adfb284547a7588c325732c913bda14d2 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96928e361282ff2bd0a3a992cfbfcb1 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ad96928e361282ff2bd0a3a992cfbfcb1">BuildTree</a> (<a class="el" href="classmeshkernel_1_1_mesh.html#a197164c7734986c1409935442b520f63">Location</a> meshLocation, const <a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a> &amp;boundingBox)</td></tr>
<tr class="memdesc:ad96928e361282ff2bd0a3a992cfbfcb1 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the rtree for the corresponding location, using only the locations inside the bounding box.  <a href="classmeshkernel_1_1_mesh.html#ad96928e361282ff2bd0a3a992cfbfcb1">More...</a><br /></td></tr>
<tr class="separator:ad96928e361282ff2bd0a3a992cfbfcb1 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673d21451c09769b5164f778bedc4c70 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a673d21451c09769b5164f778bedc4c70">SearchNearestLocation</a> (<a class="el" href="classmeshkernel_1_1_point.html">Point</a> point, <a class="el" href="classmeshkernel_1_1_mesh.html#a197164c7734986c1409935442b520f63">Location</a> meshLocation)</td></tr>
<tr class="memdesc:a673d21451c09769b5164f778bedc4c70 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search all points sorted by proximity to another point.  <a href="classmeshkernel_1_1_mesh.html#a673d21451c09769b5164f778bedc4c70">More...</a><br /></td></tr>
<tr class="separator:a673d21451c09769b5164f778bedc4c70 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ee5223d2b614f5cec051375eab801b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a00ee5223d2b614f5cec051375eab801b">SearchNearestLocation</a> (<a class="el" href="classmeshkernel_1_1_point.html">Point</a> point, double squaredRadius, <a class="el" href="classmeshkernel_1_1_mesh.html#a197164c7734986c1409935442b520f63">Location</a> meshLocation)</td></tr>
<tr class="memdesc:a00ee5223d2b614f5cec051375eab801b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the nearest point within a radius to another point.  <a href="classmeshkernel_1_1_mesh.html#a00ee5223d2b614f5cec051375eab801b">More...</a><br /></td></tr>
<tr class="separator:a00ee5223d2b614f5cec051375eab801b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadb6ba0a263f4c997f3eb9d211ac923 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#afadb6ba0a263f4c997f3eb9d211ac923">SearchLocations</a> (<a class="el" href="classmeshkernel_1_1_point.html">Point</a> point, double squaredRadius, <a class="el" href="classmeshkernel_1_1_mesh.html#a197164c7734986c1409935442b520f63">Location</a> meshLocation)</td></tr>
<tr class="memdesc:afadb6ba0a263f4c997f3eb9d211ac923 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the nearest points within a radius to another point.  <a href="classmeshkernel_1_1_mesh.html#afadb6ba0a263f4c997f3eb9d211ac923">More...</a><br /></td></tr>
<tr class="separator:afadb6ba0a263f4c997f3eb9d211ac923 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8672c19898410c6f5721d8066b53cb7b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a8672c19898410c6f5721d8066b53cb7b">GetNumLocations</a> (<a class="el" href="classmeshkernel_1_1_mesh.html#a197164c7734986c1409935442b520f63">Location</a> meshLocation) const</td></tr>
<tr class="memdesc:a8672c19898410c6f5721d8066b53cb7b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the search results. To be used after <a class="el" href="classmeshkernel_1_1_mesh.html#afadb6ba0a263f4c997f3eb9d211ac923">SearchLocations</a> or <a class="el" href="classmeshkernel_1_1_mesh.html#a673d21451c09769b5164f778bedc4c70">SearchNearestLocation</a>.  <a href="classmeshkernel_1_1_mesh.html#a8672c19898410c6f5721d8066b53cb7b">More...</a><br /></td></tr>
<tr class="separator:a8672c19898410c6f5721d8066b53cb7b inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc3101752419a1ae4cd700593ec63a0 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#affc3101752419a1ae4cd700593ec63a0">GetLocationsIndices</a> (<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> index, <a class="el" href="classmeshkernel_1_1_mesh.html#a197164c7734986c1409935442b520f63">Location</a> meshLocation)</td></tr>
<tr class="memdesc:affc3101752419a1ae4cd700593ec63a0 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index of the location, sorted by proximity. To be used after SearchNearestLocation or SearchNearestLocation.  <a href="classmeshkernel_1_1_mesh.html#affc3101752419a1ae4cd700593ec63a0">More...</a><br /></td></tr>
<tr class="separator:affc3101752419a1ae4cd700593ec63a0 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab712987123157ee36c0bdc471bba55fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ab712987123157ee36c0bdc471bba55fe">ComputeLocations</a> (<a class="el" href="classmeshkernel_1_1_mesh.html#a197164c7734986c1409935442b520f63">Location</a> location) const</td></tr>
<tr class="memdesc:ab712987123157ee36c0bdc471bba55fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a vector with the mesh locations coordinates (nodes, edges or faces coordinates).  <a href="classmeshkernel_1_1_mesh.html#ab712987123157ee36c0bdc471bba55fe">More...</a><br /></td></tr>
<tr class="separator:ab712987123157ee36c0bdc471bba55fe inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae11e12a202c2e4d2ee57fae97f9881 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#abae11e12a202c2e4d2ee57fae97f9881">operator+=</a> (<a class="el" href="classmeshkernel_1_1_mesh.html">Mesh</a> const &amp;rhs)</td></tr>
<tr class="memdesc:abae11e12a202c2e4d2ee57fae97f9881 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add meshes: result is a mesh composed of the additions firstMesh += secondmesh results in the second mesh being added to firstMesh.  <a href="classmeshkernel_1_1_mesh.html#abae11e12a202c2e4d2ee57fae97f9881">More...</a><br /></td></tr>
<tr class="separator:abae11e12a202c2e4d2ee57fae97f9881 inherit pub_methods_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a39ba7bcb74e60c8c8a38d31c7f2cedc8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#a39ba7bcb74e60c8c8a38d31c7f2cedc8">Merge</a> (const <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh1, const <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh2)</td></tr>
<tr class="memdesc:a39ba7bcb74e60c8c8a38d31c7f2cedc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges mesh connectivity.  <a href="classmeshkernel_1_1_mesh2_d.html#a39ba7bcb74e60c8c8a38d31c7f2cedc8">More...</a><br /></td></tr>
<tr class="separator:a39ba7bcb74e60c8c8a38d31c7f2cedc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af8b567d8f2cc02909e8c084adca28f9f"><td class="memItemLeft" align="right" valign="top"><a id="af8b567d8f2cc02909e8c084adca28f9f"></a>
<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh2_d.html#af8b567d8f2cc02909e8c084adca28f9f">m_maxNumNeighbours</a> = 0</td></tr>
<tr class="memdesc:af8b567d8f2cc02909e8c084adca28f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of neighbours. <br /></td></tr>
<tr class="separator:af8b567d8f2cc02909e8c084adca28f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:a130c483ec12ccfc11cddc0b1162a318e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a130c483ec12ccfc11cddc0b1162a318e"></a>
std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a130c483ec12ccfc11cddc0b1162a318e">m_nodes</a></td></tr>
<tr class="memdesc:a130c483ec12ccfc11cddc0b1162a318e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mesh nodes (xk, yk) <br /></td></tr>
<tr class="separator:a130c483ec12ccfc11cddc0b1162a318e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dea09629645fd2274c4fdff46b7fbe inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a03dea09629645fd2274c4fdff46b7fbe"></a>
std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a03dea09629645fd2274c4fdff46b7fbe">m_nodesEdges</a></td></tr>
<tr class="memdesc:a03dea09629645fd2274c4fdff46b7fbe inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each node, the indices of connected edges (nodlin) <br /></td></tr>
<tr class="separator:a03dea09629645fd2274c4fdff46b7fbe inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e9286d4ca6faaa3d67efd1ba641124 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="aa3e9286d4ca6faaa3d67efd1ba641124"></a>
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aa3e9286d4ca6faaa3d67efd1ba641124">m_nodesNumEdges</a></td></tr>
<tr class="memdesc:aa3e9286d4ca6faaa3d67efd1ba641124 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each node, the number of connected edges (nmk) <br /></td></tr>
<tr class="separator:aa3e9286d4ca6faaa3d67efd1ba641124 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626c93ced5e58d4d36ca0cec5479d148 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a626c93ced5e58d4d36ca0cec5479d148"></a>
std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a626c93ced5e58d4d36ca0cec5479d148">m_nodesNodes</a></td></tr>
<tr class="memdesc:a626c93ced5e58d4d36ca0cec5479d148 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each node, its neighbors. <br /></td></tr>
<tr class="separator:a626c93ced5e58d4d36ca0cec5479d148 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69248de9529d1c0ad698d056760e5900 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a69248de9529d1c0ad698d056760e5900"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a69248de9529d1c0ad698d056760e5900">m_nodesTypes</a></td></tr>
<tr class="memdesc:a69248de9529d1c0ad698d056760e5900 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The node types (nb) <br /></td></tr>
<tr class="separator:a69248de9529d1c0ad698d056760e5900 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b337f739ad083ffe320366f6e9dc0e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a84b337f739ad083ffe320366f6e9dc0e"></a>
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a84b337f739ad083ffe320366f6e9dc0e">m_edges</a></td></tr>
<tr class="memdesc:a84b337f739ad083ffe320366f6e9dc0e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edges, defined as first and second node(kn) <br /></td></tr>
<tr class="separator:a84b337f739ad083ffe320366f6e9dc0e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6634281d78a1ef707bc5a2376a84524 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="aa6634281d78a1ef707bc5a2376a84524"></a>
std::vector&lt; std::array&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aa6634281d78a1ef707bc5a2376a84524">m_edgesFaces</a></td></tr>
<tr class="memdesc:aa6634281d78a1ef707bc5a2376a84524 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each edge, the shared face index (lne) <br /></td></tr>
<tr class="separator:aa6634281d78a1ef707bc5a2376a84524 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9b82e327f0e73333cfb51c94cef5a1 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a0d9b82e327f0e73333cfb51c94cef5a1"></a>
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a0d9b82e327f0e73333cfb51c94cef5a1">m_edgesNumFaces</a></td></tr>
<tr class="memdesc:a0d9b82e327f0e73333cfb51c94cef5a1 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each edge, the number of shared faces(lnn) <br /></td></tr>
<tr class="separator:a0d9b82e327f0e73333cfb51c94cef5a1 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff01e492e6674565a62206fdead6762 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a5ff01e492e6674565a62206fdead6762"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a5ff01e492e6674565a62206fdead6762">m_edgeLengths</a></td></tr>
<tr class="memdesc:a5ff01e492e6674565a62206fdead6762 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edge lengths. <br /></td></tr>
<tr class="separator:a5ff01e492e6674565a62206fdead6762 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231d2889405c66b1b5e4db91d86a6ee8 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a231d2889405c66b1b5e4db91d86a6ee8"></a>
std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a231d2889405c66b1b5e4db91d86a6ee8">m_edgesCenters</a></td></tr>
<tr class="memdesc:a231d2889405c66b1b5e4db91d86a6ee8 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edges centers. <br /></td></tr>
<tr class="separator:a231d2889405c66b1b5e4db91d86a6ee8 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b44ebfdf5d280a25d566fa5a763c78 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a38b44ebfdf5d280a25d566fa5a763c78"></a>
std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a38b44ebfdf5d280a25d566fa5a763c78">m_facesNodes</a></td></tr>
<tr class="memdesc:a38b44ebfdf5d280a25d566fa5a763c78 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nodes composing the faces, in ccw order (netcellNod) <br /></td></tr>
<tr class="separator:a38b44ebfdf5d280a25d566fa5a763c78 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b727bc265546c7da3afd63059060ab inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a61b727bc265546c7da3afd63059060ab"></a>
std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a61b727bc265546c7da3afd63059060ab">m_numFacesNodes</a></td></tr>
<tr class="memdesc:a61b727bc265546c7da3afd63059060ab inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nodes composing the face (netcellN) <br /></td></tr>
<tr class="separator:a61b727bc265546c7da3afd63059060ab inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f33714b34fd0bcd708efc4b44f30b34 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a1f33714b34fd0bcd708efc4b44f30b34"></a>
std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a1f33714b34fd0bcd708efc4b44f30b34">m_facesEdges</a></td></tr>
<tr class="memdesc:a1f33714b34fd0bcd708efc4b44f30b34 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edge indices composing the face (netcelllin) <br /></td></tr>
<tr class="separator:a1f33714b34fd0bcd708efc4b44f30b34 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3342f40eb06afd71cc336010e641a227 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a3342f40eb06afd71cc336010e641a227"></a>
std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a3342f40eb06afd71cc336010e641a227">m_facesCircumcenters</a></td></tr>
<tr class="memdesc:a3342f40eb06afd71cc336010e641a227 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The face circumcenters the face circumcenter (xz, yz) <br /></td></tr>
<tr class="separator:a3342f40eb06afd71cc336010e641a227 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79821f2e74e22834dcfce0ce0a326e2e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a79821f2e74e22834dcfce0ce0a326e2e"></a>
std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a79821f2e74e22834dcfce0ce0a326e2e">m_facesMassCenters</a></td></tr>
<tr class="memdesc:a79821f2e74e22834dcfce0ce0a326e2e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The faces centers of mass (xzw, yzw) <br /></td></tr>
<tr class="separator:a79821f2e74e22834dcfce0ce0a326e2e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b24f1ea21171bfd6f803b06a4997d56 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a2b24f1ea21171bfd6f803b06a4997d56"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a2b24f1ea21171bfd6f803b06a4997d56">m_faceArea</a></td></tr>
<tr class="memdesc:a2b24f1ea21171bfd6f803b06a4997d56 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The face area. <br /></td></tr>
<tr class="separator:a2b24f1ea21171bfd6f803b06a4997d56 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c05988ff2a54a0ddf3082c7e4aeeb6 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a01c05988ff2a54a0ddf3082c7e4aeeb6"></a>
<a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a01c05988ff2a54a0ddf3082c7e4aeeb6">m_projection</a></td></tr>
<tr class="memdesc:a01c05988ff2a54a0ddf3082c7e4aeeb6 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">The projection used. <br /></td></tr>
<tr class="separator:a01c05988ff2a54a0ddf3082c7e4aeeb6 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fa3b6615a02516abcb7609abfdb44b inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="ad9fa3b6615a02516abcb7609abfdb44b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ad9fa3b6615a02516abcb7609abfdb44b">m_nodesRTreeRequiresUpdate</a> = true</td></tr>
<tr class="memdesc:ad9fa3b6615a02516abcb7609abfdb44b inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">m_nodesRTree requires an update <br /></td></tr>
<tr class="separator:ad9fa3b6615a02516abcb7609abfdb44b inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a7b51b23ecc45e373af1a53414804e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a16a7b51b23ecc45e373af1a53414804e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a16a7b51b23ecc45e373af1a53414804e">m_edgesRTreeRequiresUpdate</a> = true</td></tr>
<tr class="memdesc:a16a7b51b23ecc45e373af1a53414804e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">m_edgesRTree requires an update <br /></td></tr>
<tr class="separator:a16a7b51b23ecc45e373af1a53414804e inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599e1a3c41f2efbae020cd63e164e649 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a599e1a3c41f2efbae020cd63e164e649"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a599e1a3c41f2efbae020cd63e164e649">m_facesRTreeRequiresUpdate</a> = true</td></tr>
<tr class="memdesc:a599e1a3c41f2efbae020cd63e164e649 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">m_facesRTree requires an update <br /></td></tr>
<tr class="separator:a599e1a3c41f2efbae020cd63e164e649 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ab281fde2432c3de99d4f7148bbe3a inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a10ab281fde2432c3de99d4f7148bbe3a"></a>
RTree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a10ab281fde2432c3de99d4f7148bbe3a">m_nodesRTree</a></td></tr>
<tr class="memdesc:a10ab281fde2432c3de99d4f7148bbe3a inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial R-Tree used to inquire node nodes. <br /></td></tr>
<tr class="separator:a10ab281fde2432c3de99d4f7148bbe3a inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb30c32af4e98b0772e8c3d55a670a8 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="abbb30c32af4e98b0772e8c3d55a670a8"></a>
RTree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#abbb30c32af4e98b0772e8c3d55a670a8">m_edgesRTree</a></td></tr>
<tr class="memdesc:abbb30c32af4e98b0772e8c3d55a670a8 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial R-Tree used to inquire edges centers. <br /></td></tr>
<tr class="separator:abbb30c32af4e98b0772e8c3d55a670a8 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d44668af534ba075870c6be5567c9b7 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a0d44668af534ba075870c6be5567c9b7"></a>
RTree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a0d44668af534ba075870c6be5567c9b7">m_facesRTree</a></td></tr>
<tr class="memdesc:a0d44668af534ba075870c6be5567c9b7 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial R-Tree used to inquire face circumcenters. <br /></td></tr>
<tr class="separator:a0d44668af534ba075870c6be5567c9b7 inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace21416da05353ed324bc2871e2d81aa inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="ace21416da05353ed324bc2871e2d81aa"></a>
<a class="el" href="classmeshkernel_1_1_bounding_box.html">BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#ace21416da05353ed324bc2871e2d81aa">m_boundingBoxCache</a></td></tr>
<tr class="memdesc:ace21416da05353ed324bc2871e2d81aa inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Caches the last bounding box used for selecting the locations. <br /></td></tr>
<tr class="separator:ace21416da05353ed324bc2871e2d81aa inherit pub_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classmeshkernel_1_1_mesh"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classmeshkernel_1_1_mesh')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classmeshkernel_1_1_mesh.html">meshkernel::Mesh</a></td></tr>
<tr class="memitem:af2ac1b6f6c9f21894e579ecad4ee2da3 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top">static const std::map&lt; <a class="el" href="classmeshkernel_1_1_mesh.html#a197164c7734986c1409935442b520f63">Location</a>, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#af2ac1b6f6c9f21894e579ecad4ee2da3">LocationToString</a></td></tr>
<tr class="memdesc:af2ac1b6f6c9f21894e579ecad4ee2da3 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps Location enumeration to a string.  <a href="classmeshkernel_1_1_mesh.html#af2ac1b6f6c9f21894e579ecad4ee2da3">More...</a><br /></td></tr>
<tr class="separator:af2ac1b6f6c9f21894e579ecad4ee2da3 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fbec78aa3205dd3aa45393869672c5 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a40fbec78aa3205dd3aa45393869672c5"></a>
static constexpr <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a40fbec78aa3205dd3aa45393869672c5">m_maximumNumberOfEdgesPerNode</a> = 16</td></tr>
<tr class="memdesc:a40fbec78aa3205dd3aa45393869672c5 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of edges per node. <br /></td></tr>
<tr class="separator:a40fbec78aa3205dd3aa45393869672c5 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd1f56e9f2ca719b52e92c5e59aa6e4 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a7fd1f56e9f2ca719b52e92c5e59aa6e4"></a>
static constexpr <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a7fd1f56e9f2ca719b52e92c5e59aa6e4">m_maximumNumberOfEdgesPerFace</a> = 6</td></tr>
<tr class="memdesc:a7fd1f56e9f2ca719b52e92c5e59aa6e4 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of edges per face. <br /></td></tr>
<tr class="separator:a7fd1f56e9f2ca719b52e92c5e59aa6e4 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ba1181dd7432ce3e1cd77169c4b6a0 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="aa0ba1181dd7432ce3e1cd77169c4b6a0"></a>
static constexpr <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#aa0ba1181dd7432ce3e1cd77169c4b6a0">m_maximumNumberOfNodesPerFace</a> = 6</td></tr>
<tr class="memdesc:aa0ba1181dd7432ce3e1cd77169c4b6a0 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of nodes per face. <br /></td></tr>
<tr class="separator:aa0ba1181dd7432ce3e1cd77169c4b6a0 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7951192d95f5fd0a5c13b26084f69df7 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memItemLeft" align="right" valign="top"><a id="a7951192d95f5fd0a5c13b26084f69df7"></a>
static constexpr <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernel_1_1_mesh.html#a7951192d95f5fd0a5c13b26084f69df7">m_maximumNumberOfConnectedNodes</a> = <a class="el" href="classmeshkernel_1_1_mesh.html#a40fbec78aa3205dd3aa45393869672c5">m_maximumNumberOfEdgesPerNode</a> * 4</td></tr>
<tr class="memdesc:a7951192d95f5fd0a5c13b26084f69df7 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of connected nodes. <br /></td></tr>
<tr class="separator:a7951192d95f5fd0a5c13b26084f69df7 inherit pub_static_attribs_classmeshkernel_1_1_mesh"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class derived from <a class="el" href="classmeshkernel_1_1_mesh.html" title="A class describing an unstructured mesh. This class contains the shared functionality between 1d or 2...">Mesh</a>, which describes unstructures 2d meshes. </p>
<p>When communicating with the client only unstructured meshes are used. Some algorithms generate curvilinear grids, but these are converted to a mesh instance when communicating with the client. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab971b113521125e64ab3218bcfdaadef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab971b113521125e64ab3218bcfdaadef">&#9670;&nbsp;</a></span>Mesh2D() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh2D::Mesh2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a mesh2d using only the projection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The projection to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac667a2395d4b205d7c4be2536bc301eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac667a2395d4b205d7c4be2536bc301eb">&#9670;&nbsp;</a></span>Mesh2D() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh2D::Mesh2D </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a mesh2d starting from the edges and nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>The input edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>The input nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The projection to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3f666425d7520ef162b4c546cc8b59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f666425d7520ef162b4c546cc8b59a">&#9670;&nbsp;</a></span>Mesh2D() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh2D::Mesh2D </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a07234cba2b9eb4b8df84a19a3f709cf8">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>faceNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>numFaceNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a mesh2d from face nodes and num face nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>The input edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>The input nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceNodes</td><td>The input face nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numFaceNodes</td><td>For each face, the number of nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The mesh projection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae466a7ef61c51eb720f50d31ed94ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae466a7ef61c51eb720f50d31ed94ca1">&#9670;&nbsp;</a></span>Mesh2D() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">meshkernel::Mesh2D::Mesh2D </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a22d09b6f79c4d1aa55aafadb84908716">Projection</a>&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create triangular grid from nodes (triangulatesamplestonetwork) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>Input nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>Selection polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>The projection to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a281602c3eee4a57f2f06a89badafa04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281602c3eee4a57f2f06a89badafa04d">&#9670;&nbsp;</a></span>ComputeAspectRatios()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::ComputeAspectRatios </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>aspectRatios</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the aspect ratios (the ratios edges lengths to flow edges lengths) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">aspectRatios</td><td>The aspect ratios (passed as reference to avoid re-allocation) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4383fa3d1ca1d1aed4405a629330f4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4383fa3d1ca1d1aed4405a629330f4a1">&#9670;&nbsp;</a></span>ComputeFaceCircumenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmeshkernel_1_1_point.html">Point</a> meshkernel::Mesh2D::ComputeFaceCircumenter </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgesNumFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a closed polygon, compute the circumcenter of a face (getcircumcenter) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">polygon</td><td>Cache storing the face nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edgesNumFaces</td><td>For meshes, the number of faces sharing the edges </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed circumcenter </dd></dl>

</div>
</div>
<a id="abdbc0d31cca18d130630e3ed8fa653ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbc0d31cca18d130630e3ed8fa653ff">&#9670;&nbsp;</a></span>ComputeFaceClosedPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::ComputeFaceClosedPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>faceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygonNodesCache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a face create a closed polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face index </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">polygonNodesCache</td><td>The cache array to be filled with the nodes values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35186078240ebfeac3c6bf9db8160cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35186078240ebfeac3c6bf9db8160cd2">&#9670;&nbsp;</a></span>ComputeFaceClosedPolygonWithLocalMappings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::ComputeFaceClosedPolygonWithLocalMappings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>faceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygonNodesCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>localNodeIndicesCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>globalEdgeIndicesCache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a face create a closed polygon and fill local mapping caches (get_cellpolygon) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">faceIndex</td><td>The face index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">polygonNodesCache</td><td>The node cache array filled with the nodes values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">localNodeIndicesCache</td><td>The consecutive node index in polygonNodesCache (0, 1, 2,...) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">globalEdgeIndicesCache</td><td>The edge cache array filled with the global edge indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cce62a059fa51a0c94b52f33a456eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cce62a059fa51a0c94b52f33a456eed">&#9670;&nbsp;</a></span>DeleteMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::DeleteMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deletionOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invertDeletion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a mesh in a polygon, using several options (delnet) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The polygon where to perform the operation If this <a class="el" href="classmeshkernel_1_1_polygons.html" title="A class containing a list of polygonaly enclosed regions.">Polygons</a> instance contains multiple polygons, the first one will be taken. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deletionOption</td><td>The deletion option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">invertDeletion</td><td>Inverts the selected node to delete (instead of outside the polygon, inside the polygon) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6855534ffcff0ca5ac4ce4e1bc4ca229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6855534ffcff0ca5ac4ce4e1bc4ca229">&#9670;&nbsp;</a></span>DeleteSmallFlowEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::DeleteSmallFlowEdges </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>smallFlowEdgesThreshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes small flow edges (removesmallflowlinks, part 1) </p>
<p>An unstructured mesh can be used to calculate water flow. This involves a pressure gradient between the circumcenters of neighbouring faces. That procedure is numerically unreliable when the distance between face circumcenters (flow edges) becomes too small. Let's consider the following figure </p><div class="image">
<object type="image/svg+xml" data="coincide_circumcenter.svg" style="pointer-events: none;"></object>
<div class="caption">
Coincide circumcenter</div></div>
<p> The algorithm works as follow:</p>
<ul>
<li>Any degenerated triangle (e.g. those having a coinciding node) is removed by collapsing the second and third node into the first one.</li>
<li><p class="startli">The edges crossing small flow edges are found. The flow edge length is computed from the face circumcenters and compared to an estimated cut off distance. The cutoff distance is computed using the face areas as follow:</p>
<p class="startli">\(\textrm{cutOffDistance} = \textrm{threshold} \cdot 0.5 \cdot (\sqrt{\textrm{Area}_I}+\sqrt{\textrm{Area}_{II}})\)</p>
</li>
<li>All small flow edges are flagged with invalid indices and removed from the mesh. Removal occors in the <a class="el" href="classmeshkernel_1_1_mesh2_d.html#af19223d2ef844428f5858291f588ad47">Mesh2D::Administrate</a> method. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smallFlowEdgesThreshold</td><td>The configurable threshold for detecting the small flow edges </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="af03d80377cafe9fdfb22545423fb8fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03d80377cafe9fdfb22545423fb8fa6">&#9670;&nbsp;</a></span>DeleteSmallTrianglesAtBoundaries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::DeleteSmallTrianglesAtBoundaries </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minFractionalAreaTriangles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes small triangles at the boundaries (removesmallflowlinks, part 2) </p>
<p>This algorithm removes triangles having the following properties:</p><ul>
<li>The are at mesh boundary.</li>
<li>One or more neighboring faces are non-triangles.</li>
<li>The ratio of the face area to the average area of neighboring non triangles is less than a minimum ratio (defaults to 0.2).</li>
<li>The absolute cosine of one internal angle is less than 0.2.</li>
</ul>
<p>These triangles having the above properties are merged by collapsing the face nodes to the node having the minimum absolute cosine (e.g. the node where the internal angle is closer to 90 degrees). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minFractionalAreaTriangles</td><td>Small triangles at the boundaries will be eliminated. This threshold is the ration of the face area to the average area of neighboring faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4db6fe647045d8c4fe81e44b1dcb7125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db6fe647045d8c4fe81e44b1dcb7125">&#9670;&nbsp;</a></span>FindOppositeEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh2D::FindOppositeEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>faceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edgeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find edge on the opposite side of the element. </p>
<dl class="section note"><dt>Note</dt><dd>Currently only valid of quadrilateral elements. Will throw exception <a class="el" href="classmeshkernel_1_1_not_implemented_error.html" title="A class for throwing not implemented exceptions.">NotImplementedError</a> for non-quadrilateral element shapes. </dd></dl>

</div>
</div>
<a id="a6a40ea7da15823130792bcb0d74214a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a40ea7da15823130792bcb0d74214a2">&#9670;&nbsp;</a></span>GetEdgesCrossingSmallFlowEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&gt; meshkernel::Mesh2D::GetEdgesCrossingSmallFlowEdges </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>smallFlowEdgesThreshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the edges crossing the small flow edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smallFlowEdgesThreshold</td><td>The configurable threshold for detecting the small flow edges </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The indices of the edges crossing small flow edges </dd></dl>

</div>
</div>
<a id="acd5a26d4f62a3ef41c124b87cfbb7bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5a26d4f62a3ef41c124b87cfbb7bae">&#9670;&nbsp;</a></span>GetFlowEdgesCenters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classmeshkernel_1_1_point.html">Point</a>&gt; meshkernel::Mesh2D::GetFlowEdgesCenters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the flow edges centers from the crossing edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>The crossing edges indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The centers of the flow edges </dd></dl>

</div>
</div>
<a id="a54988d04981fbfcc21077fbd44229910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54988d04981fbfcc21077fbd44229910">&#9670;&nbsp;</a></span>GetHangingEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&gt; meshkernel::Mesh2D::GetHangingEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the hanging edges. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector with the indices of the hanging edges </dd></dl>

</div>
</div>
<a id="aea6575301bc3c4c17e3a76c5efca4ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6575301bc3c4c17e3a76c5efca4ad5">&#9670;&nbsp;</a></span>GetObtuseTrianglesCenters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classmeshkernel_1_1_point.html">Point</a>&gt; meshkernel::Mesh2D::GetObtuseTrianglesCenters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mass centers of obtuse triangles. </p>
<dl class="section return"><dt>Returns</dt><dd>The center of obtuse triangles </dd></dl>

</div>
</div>
<a id="afaa6bfaadd219f15bbb7b45ee696a256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa6bfaadd219f15bbb7b45ee696a256">&#9670;&nbsp;</a></span>GetOrthogonality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; meshkernel::Mesh2D::GetOrthogonality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the orthogonality values, the inner product of edges and segments connecting the face circumcenters. </p>
<dl class="section return"><dt>Returns</dt><dd>The edge orthogonality </dd></dl>

</div>
</div>
<a id="ad2aca39594f2a68e3717829f98ba04d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2aca39594f2a68e3717829f98ba04d0">&#9670;&nbsp;</a></span>GetPolylineIntersections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::vector&lt;<a class="el" href="structmeshkernel_1_1_mesh_1_1_edge_mesh_polyline_intersection.html">EdgeMeshPolylineIntersection</a>&gt;, std::vector&lt;<a class="el" href="structmeshkernel_1_1_mesh_1_1_face_mesh_polyline_intersection.html">FaceMeshPolylineIntersection</a>&gt; &gt; meshkernel::Mesh2D::GetPolylineIntersections </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polyLine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the edges and faces intersected by a polyline, with additional information on the intersections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polyLine</td><td>An input polyline, defined as a series of points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing a vector of EdgeMeshPolylineIntersections and FaceMeshPolylineIntersections </dd></dl>

</div>
</div>
<a id="aee516031de33d12a21a5d0aae1007162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee516031de33d12a21a5d0aae1007162">&#9670;&nbsp;</a></span>GetSmoothness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; meshkernel::Mesh2D::GetSmoothness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the smoothness values, ratios of the face areas. </p>
<dl class="section return"><dt>Returns</dt><dd>The smoothness at the edges </dd></dl>

</div>
</div>
<a id="a8e7e8009c8aebe6d3d8420be59d7b882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7e8009c8aebe6d3d8420be59d7b882">&#9670;&nbsp;</a></span>IsSegmentCrossingABoundaryEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>, <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&gt; meshkernel::Mesh2D::IsSegmentCrossingABoundaryEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>firstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>secondPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inquire if a segment is crossing a face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstPoint</td><td>The first point of the segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondPoint</td><td>The second point of the segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple with the intersectedFace face index and intersected edge index </dd></dl>

</div>
</div>
<a id="a1acdab15ff562599311e2264f4728844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1acdab15ff562599311e2264f4728844">&#9670;&nbsp;</a></span>MakeDualFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::MakeDualFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>enlargementFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dualFace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a dual face around the node, enlarged by a factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enlargementFactor</td><td>The factor by which the dual face is enlarged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dualFace</td><td>The dual face to be calculated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7decde6c1988555f70610c313e68342a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7decde6c1988555f70610c313e68342a">&#9670;&nbsp;</a></span>MaskEdgesOfFacesInPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; meshkernel::Mesh2D::MaskEdgesOfFacesInPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invertSelection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeIntersected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Masks the edges of all faces entirely included in all polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The selection polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">invertSelection</td><td>Invert selection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">includeIntersected</td><td>Included the edges intersected by the polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edge mask </dd></dl>

</div>
</div>
<a id="a39ba7bcb74e60c8c8a38d31c7f2cedc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ba7bcb74e60c8c8a38d31c7f2cedc8">&#9670;&nbsp;</a></span>Merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> meshkernel::Mesh2D::Merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges mesh connectivity. </p>
<p>Only merges the mesh connectivity graphs and updates indices. </p><dl class="section note"><dt>Note</dt><dd>Does not do any administration on the node, edges or elements, it may be required to call Administrate after merging </dd></dl>

</div>
</div>
<a id="acf52d4c97ef09036a3110ab61fab031b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf52d4c97ef09036a3110ab61fab031b">&#9670;&nbsp;</a></span>MeshBoundaryToPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classmeshkernel_1_1_point.html">Point</a>&gt; meshkernel::Mesh2D::MeshBoundaryToPolygon </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all mesh boundaries to a vector of polygon nodes, including holes (copynetboundstopol) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The polygon where the operation is performed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting polygon mesh boundary </dd></dl>

</div>
</div>
<a id="a399739726d1d913f8b23a385abe536aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399739726d1d913f8b23a385abe536aa">&#9670;&nbsp;</a></span>NextFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> meshkernel::Mesh2D::NextFace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>faceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>edgeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next face adjacent to the edge on the opposite side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">faceId</td><td>The starting face </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeId</td><td>The starting edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of neighbour face along the edge </dd></dl>

</div>
</div>
<a id="a0842f06cb37b04dea67fb797056cd216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0842f06cb37b04dea67fb797056cd216">&#9670;&nbsp;</a></span>NodeMaskFromEdgeMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; meshkernel::Mesh2D::NodeMaskFromEdgeMask </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>edgeMask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From the edge mask compute the node mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeMask</td><td>The edge mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node mask </dd></dl>

</div>
</div>
<a id="adbc47b25ff52ee8fd178b357c7abfe91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc47b25ff52ee8fd178b357c7abfe91">&#9670;&nbsp;</a></span>NodeMaskFromPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; meshkernel::Mesh2D::NodeMaskFromPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygons.html">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inside</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask all nodes included in all polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The input polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inside</td><td>Inside or outside option </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node mask </dd></dl>

</div>
</div>
<a id="a9e874419b2e05ab89e9000f16f3e905b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e874419b2e05ab89e9000f16f3e905b">&#9670;&nbsp;</a></span>OffsetSphericalCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::OffsetSphericalCoordinates </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>miny</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset the x coordinates if m_projection is spherical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minx</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">miny</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ad446a7de6ca7ea10fa864ef35e02c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad446a7de6ca7ea10fa864ef35e02c3">&#9670;&nbsp;</a></span>PointFaceIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&gt; meshkernel::Mesh2D::PointFaceIndices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a collection of points, compute the face indices including them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>The input point vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face indices including the points. </dd></dl>

</div>
</div>
<a id="afa1a11d73e8a0c2974e5cd00d628f584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1a11d73e8a0c2974e5cd00d628f584">&#9670;&nbsp;</a></span>SortedFacesAroundNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&gt; meshkernel::Mesh2D::SortedFacesAroundNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the faces around a node, sorted in counter clock wise order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face indexses </dd></dl>

</div>
</div>
<a id="a9ccf24cf23136393e36d0fd07bbbfff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ccf24cf23136393e36d0fd07bbbfff2">&#9670;&nbsp;</a></span>WalkBoundaryFromNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void meshkernel::Mesh2D::WalkBoundaryFromNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmeshkernel_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>isVisited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemeshkernel.html#a97cee6f31f2b12e413c4b37aceaccf28">UInt</a> &amp;&#160;</td>
          <td class="paramname"><em>currentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmeshkernel_1_1_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshBoundaryPolygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a polygon from the meshboundary, by walking through the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The input polygon </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">isVisited</td><td>the visited mesh nodes </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">currentNode</td><td>the current node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">meshBoundaryPolygon</td><td>The resulting polygon points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/MeshKernel/MeshKernel/libs/MeshKernel/include/MeshKernel/<a class="el" href="include_2_mesh_kernel_2_mesh2_d_8hpp_source.html">Mesh2D.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
