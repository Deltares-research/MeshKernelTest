<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeshKernel: meshkernelapi Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MeshKernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">meshkernelapi Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains all structs and functions exposed at the API level.  
<a href="namespacemeshkernelapi.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_contacts.html">Contacts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to describe contacts between a 1d and a 2d mesh.  <a href="structmeshkernelapi_1_1_contacts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html">CurvilinearGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to describe the values of a curvilinear grid in a C-compatible manner.  <a href="structmeshkernelapi_1_1_curvilinear_grid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_curvilinear_parameters.html">CurvilinearParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to describe parameters for generating a curvilinear grid in a C-compatible manner.  <a href="structmeshkernelapi_1_1_curvilinear_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to describe a list of geometries in a C-compatible manner.  <a href="structmeshkernelapi_1_1_geometry_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_interpolation_parameters.html">InterpolationParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to describe the interpolation parameters in a C-compatible manner.  <a href="structmeshkernelapi_1_1_interpolation_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_make_mesh_parameters.html">MakeMeshParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct describes the necessary parameters to create a new mesh in a C-compatible manner.  <a href="structmeshkernelapi_1_1_make_mesh_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_mesh1_d.html">Mesh1D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to describe the values of a mesh 1d in a C-compatible manner.  <a href="structmeshkernelapi_1_1_mesh1_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manner.  <a href="structmeshkernelapi_1_1_mesh2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmeshkernelapi_1_1_mesh_kernel_state.html">MeshKernelState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class holding the state of the C API library.  <a href="classmeshkernelapi_1_1_mesh_kernel_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_orthogonalization_parameters.html">OrthogonalizationParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to describe the orthogonalization parameters in a C-compatible manner.  <a href="structmeshkernelapi_1_1_orthogonalization_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_sample_refine_parameters.html">SampleRefineParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to describe the sample refine parameters in a C-compatible manner.  <a href="structmeshkernelapi_1_1_sample_refine_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmeshkernelapi_1_1_splines_to_curvilinear_parameters.html">SplinesToCurvilinearParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to describe the spline to curvilinear grid parameters in a C-compatible manner.  <a href="structmeshkernelapi_1_1_splines_to_curvilinear_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab64bcc281e5dc1365be7240a26d7244e"><td class="memItemLeft" align="right" valign="top"><a id="ab64bcc281e5dc1365be7240a26d7244e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ab64bcc281e5dc1365be7240a26d7244e">MeshKernelApiErrors</a> { <b>Success</b> = 0, 
<b>Exception</b> = 1, 
<b>InvalidGeometry</b> = 2
 }</td></tr>
<tr class="memdesc:ab64bcc281e5dc1365be7240a26d7244e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration for api error types. <br /></td></tr>
<tr class="separator:ab64bcc281e5dc1365be7240a26d7244e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6fb9ca3c9bf8888d566fa3564ee10557"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a6fb9ca3c9bf8888d566fa3564ee10557">mkernel_allocate_state</a> (int isGeographic, int &amp;meshKernelId)</td></tr>
<tr class="memdesc:a6fb9ca3c9bf8888d566fa3564ee10557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mesh state and returns the generated <code>meshKernelId</code>.  <a href="namespacemeshkernelapi.html#a6fb9ca3c9bf8888d566fa3564ee10557">More...</a><br /></td></tr>
<tr class="separator:a6fb9ca3c9bf8888d566fa3564ee10557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d1b16ba8121e1f11b1692b755647c3"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a57d1b16ba8121e1f11b1692b755647c3">mkernel_deallocate_state</a> (int meshKernelId)</td></tr>
<tr class="memdesc:a57d1b16ba8121e1f11b1692b755647c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate mesh state.  <a href="namespacemeshkernelapi.html#a57d1b16ba8121e1f11b1692b755647c3">More...</a><br /></td></tr>
<tr class="separator:a57d1b16ba8121e1f11b1692b755647c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accced3de4893e24a53cce7480acaf03e"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#accced3de4893e24a53cce7480acaf03e">mkernel_delete_mesh2d</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygon, int deletionOption, bool invertDeletion)</td></tr>
<tr class="memdesc:accced3de4893e24a53cce7480acaf03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a mesh in a polygon using several options.  <a href="namespacemeshkernelapi.html#accced3de4893e24a53cce7480acaf03e">More...</a><br /></td></tr>
<tr class="separator:accced3de4893e24a53cce7480acaf03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68f65ac929aef17ef7c08598ddfb3ea"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ac68f65ac929aef17ef7c08598ddfb3ea">mkernel_set_mesh2d</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh2d)</td></tr>
<tr class="memdesc:ac68f65ac929aef17ef7c08598ddfb3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classmeshkernel_1_1_mesh2_d.html" title="A class derived from Mesh, which describes unstructures 2d meshes.">meshkernel::Mesh2D</a> state.  <a href="namespacemeshkernelapi.html#ac68f65ac929aef17ef7c08598ddfb3ea">More...</a><br /></td></tr>
<tr class="separator:ac68f65ac929aef17ef7c08598ddfb3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d17e2e5e58e7cee09cbd6bfcb5cd370"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a4d17e2e5e58e7cee09cbd6bfcb5cd370">mkernel_set_mesh1d</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html">Mesh1D</a> &amp;mesh1d)</td></tr>
<tr class="memdesc:a4d17e2e5e58e7cee09cbd6bfcb5cd370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classmeshkernel_1_1_mesh1_d.html" title="A class derived from Mesh, which describes 1d meshes.">meshkernel::Mesh1D</a> state.  <a href="namespacemeshkernelapi.html#a4d17e2e5e58e7cee09cbd6bfcb5cd370">More...</a><br /></td></tr>
<tr class="separator:a4d17e2e5e58e7cee09cbd6bfcb5cd370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb327095fac9936a6787580cf25dcd21"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#acb327095fac9936a6787580cf25dcd21">mkernel_get_dimensions_mesh2d</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh2d)</td></tr>
<tr class="memdesc:acb327095fac9936a6787580cf25dcd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> dimensions.  <a href="namespacemeshkernelapi.html#acb327095fac9936a6787580cf25dcd21">More...</a><br /></td></tr>
<tr class="separator:acb327095fac9936a6787580cf25dcd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0212fa98df8ef054e17ce4a4f2a01561"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a0212fa98df8ef054e17ce4a4f2a01561">mkernel_get_data_mesh2d</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh2d)</td></tr>
<tr class="memdesc:a0212fa98df8ef054e17ce4a4f2a01561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> dimensions data.  <a href="namespacemeshkernelapi.html#a0212fa98df8ef054e17ce4a4f2a01561">More...</a><br /></td></tr>
<tr class="separator:a0212fa98df8ef054e17ce4a4f2a01561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ebd6b10e71b31df22ed390f53ce571"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a02ebd6b10e71b31df22ed390f53ce571">mkernel_get_dimensions_curvilinear</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html">CurvilinearGrid</a> &amp;curvilinearGrid)</td></tr>
<tr class="memdesc:a02ebd6b10e71b31df22ed390f53ce571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the curvilinear grid dimensions as a <a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html" title="A struct used to describe the values of a curvilinear grid in a C-compatible manner.">CurvilinearGrid</a> struct (converted as set of edges and nodes)  <a href="namespacemeshkernelapi.html#a02ebd6b10e71b31df22ed390f53ce571">More...</a><br /></td></tr>
<tr class="separator:a02ebd6b10e71b31df22ed390f53ce571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af466d153595d03f337513cf3a5710eba"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#af466d153595d03f337513cf3a5710eba">mkernel_get_data_curvilinear</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html">CurvilinearGrid</a> &amp;curvilinearGrid)</td></tr>
<tr class="memdesc:af466d153595d03f337513cf3a5710eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the curvilinear grid data as a <a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html" title="A struct used to describe the values of a curvilinear grid in a C-compatible manner.">CurvilinearGrid</a> struct (converted as set of edges and nodes)  <a href="namespacemeshkernelapi.html#af466d153595d03f337513cf3a5710eba">More...</a><br /></td></tr>
<tr class="separator:af466d153595d03f337513cf3a5710eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa403ef1b510b3afe20b9849464fdcaaf"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aa403ef1b510b3afe20b9849464fdcaaf">mkernel_get_dimensions_mesh1d</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html">Mesh1D</a> &amp;mesh1d)</td></tr>
<tr class="memdesc:aa403ef1b510b3afe20b9849464fdcaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a> dimensions.  <a href="namespacemeshkernelapi.html#aa403ef1b510b3afe20b9849464fdcaaf">More...</a><br /></td></tr>
<tr class="separator:aa403ef1b510b3afe20b9849464fdcaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75c66c025de2d0af52e3f0a429ae851"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#af75c66c025de2d0af52e3f0a429ae851">mkernel_get_data_mesh1d</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html">Mesh1D</a> &amp;mesh1d)</td></tr>
<tr class="memdesc:af75c66c025de2d0af52e3f0a429ae851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a> dimensions data.  <a href="namespacemeshkernelapi.html#af75c66c025de2d0af52e3f0a429ae851">More...</a><br /></td></tr>
<tr class="separator:af75c66c025de2d0af52e3f0a429ae851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e855bbd0f383630b4ffd1a548a0def"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a97e855bbd0f383630b4ffd1a548a0def">mkernel_get_dimensions_contacts</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_contacts.html">Contacts</a> &amp;contacts)</td></tr>
<tr class="memdesc:a97e855bbd0f383630b4ffd1a548a0def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of contacts.  <a href="namespacemeshkernelapi.html#a97e855bbd0f383630b4ffd1a548a0def">More...</a><br /></td></tr>
<tr class="separator:a97e855bbd0f383630b4ffd1a548a0def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77639a92507d619d56b96e5964ff992f"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a77639a92507d619d56b96e5964ff992f">mkernel_get_data_contacts</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_contacts.html">Contacts</a> &amp;contacts)</td></tr>
<tr class="memdesc:a77639a92507d619d56b96e5964ff992f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the contacts indices (from index / to indices)  <a href="namespacemeshkernelapi.html#a77639a92507d619d56b96e5964ff992f">More...</a><br /></td></tr>
<tr class="separator:a77639a92507d619d56b96e5964ff992f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a2b0f3831d51c06e32e893e11ce56e"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a02a2b0f3831d51c06e32e893e11ce56e">mkernel_count_hanging_edges_mesh2d</a> (int meshKernelId, int &amp;numEdges)</td></tr>
<tr class="memdesc:a02a2b0f3831d51c06e32e893e11ce56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of hanging edges in a mesh2d. An hanging edge is an edge where one of the two nodes is not connected.  <a href="namespacemeshkernelapi.html#a02a2b0f3831d51c06e32e893e11ce56e">More...</a><br /></td></tr>
<tr class="separator:a02a2b0f3831d51c06e32e893e11ce56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aa8fc7522fbab81f7fd2deed07cb45"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a21aa8fc7522fbab81f7fd2deed07cb45">mkernel_get_hanging_edges_mesh2d</a> (int meshKernelId, int **edges)</td></tr>
<tr class="memdesc:a21aa8fc7522fbab81f7fd2deed07cb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the indices of hanging edges. An hanging edge is an edge where one of the two nodes is not connected.  <a href="namespacemeshkernelapi.html#a21aa8fc7522fbab81f7fd2deed07cb45">More...</a><br /></td></tr>
<tr class="separator:a21aa8fc7522fbab81f7fd2deed07cb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75ffce4b12d93ff0c4f28182725399b"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#af75ffce4b12d93ff0c4f28182725399b">mkernel_delete_hanging_edges_mesh2d</a> (int meshKernelId)</td></tr>
<tr class="memdesc:af75ffce4b12d93ff0c4f28182725399b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all hanging edges. An hanging edge is an edge where one of the two nodes is not connected.  <a href="namespacemeshkernelapi.html#af75ffce4b12d93ff0c4f28182725399b">More...</a><br /></td></tr>
<tr class="separator:af75ffce4b12d93ff0c4f28182725399b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17462ce61816890c3782834ba591468"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ae17462ce61816890c3782834ba591468">mkernel_compute_orthogonalization_mesh2d</a> (int meshKernelId, int projectToLandBoundaryOption, const <a class="el" href="structmeshkernelapi_1_1_orthogonalization_parameters.html">OrthogonalizationParameters</a> &amp;orthogonalizationParameters, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygons, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;landBoundaries)</td></tr>
<tr class="memdesc:ae17462ce61816890c3782834ba591468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh2d orthogonalization. The function modifies the mesh for achieving orthogonality between the edges and the segments connecting the face circumcenters. The amount of orthogonality is traded against the mesh smoothing (in this case the equality of face areas). The parameter to regulate the amount of orthogonalization is contained in <a class="el" href="structmeshkernelapi_1_1_orthogonalization_parameters.html#a5ffb52364fd8c379dda2bb37c24200c4">meshkernelapi::OrthogonalizationParameters::OrthogonalizationToSmoothingFactor</a>.  <a href="namespacemeshkernelapi.html#ae17462ce61816890c3782834ba591468">More...</a><br /></td></tr>
<tr class="separator:ae17462ce61816890c3782834ba591468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5eb7f2190125044064fb6cd3495ecd"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a1c5eb7f2190125044064fb6cd3495ecd">mkernel_initialize_orthogonalization_mesh2d</a> (int meshKernelId, int projectToLandBoundaryOption, <a class="el" href="structmeshkernelapi_1_1_orthogonalization_parameters.html">OrthogonalizationParameters</a> &amp;orthogonalizationParameters, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListPolygon, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListLandBoundaries)</td></tr>
<tr class="memdesc:a1c5eb7f2190125044064fb6cd3495ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of the <a class="el" href="classmeshkernel_1_1_orthogonalization_and_smoothing.html">meshkernel::OrthogonalizationAndSmoothing</a> algorithm. This is the first function to call when using orthogonalization in interactive mode (visualizing the grid while is orthogonalizing), in order to set the internal state of the algorithm reused during the iterations.  <a href="namespacemeshkernelapi.html#a1c5eb7f2190125044064fb6cd3495ecd">More...</a><br /></td></tr>
<tr class="separator:a1c5eb7f2190125044064fb6cd3495ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad920018b836147d687c69e83a037ae69"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ad920018b836147d687c69e83a037ae69">mkernel_prepare_outer_iteration_orthogonalization_mesh2d</a> (int meshKernelId)</td></tr>
<tr class="memdesc:ad920018b836147d687c69e83a037ae69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares an outer orthogonalization iteration, computing the new orthogonalization and smoothing weights from the modified geometry (in interactive mode) <code>mkernel_initialize_orthogonalization_mesh2d</code> function must be called before.  <a href="namespacemeshkernelapi.html#ad920018b836147d687c69e83a037ae69">More...</a><br /></td></tr>
<tr class="separator:ad920018b836147d687c69e83a037ae69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8e39e81f15084af773c0bae2bf350b"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aaf8e39e81f15084af773c0bae2bf350b">mkernel_compute_inner_ortogonalization_iteration_mesh2d</a> (int meshKernelId)</td></tr>
<tr class="memdesc:aaf8e39e81f15084af773c0bae2bf350b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs inner orthogonalization iteration, by slowly moving the mesh nodes to new optimal positions (interactive mode). <code>mkernel_prepare_outer_iteration_orthogonalization_mesh2d</code> function must be called before.  <a href="namespacemeshkernelapi.html#aaf8e39e81f15084af773c0bae2bf350b">More...</a><br /></td></tr>
<tr class="separator:aaf8e39e81f15084af773c0bae2bf350b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cec4a22944557a5a49657fbf081c18d"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a3cec4a22944557a5a49657fbf081c18d">mkernel_finalize_inner_ortogonalization_iteration_mesh2d</a> (int meshKernelId)</td></tr>
<tr class="memdesc:a3cec4a22944557a5a49657fbf081c18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes the orthogonalization outer iteration, computing the new coefficients for grid adaption and the new face circumcenters (interactive mode).  <a href="namespacemeshkernelapi.html#a3cec4a22944557a5a49657fbf081c18d">More...</a><br /></td></tr>
<tr class="separator:a3cec4a22944557a5a49657fbf081c18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a156d1dce89ff4ba435038ce909783"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aa8a156d1dce89ff4ba435038ce909783">mkernel_delete_orthogonalization_mesh2d</a> (int meshKernelId)</td></tr>
<tr class="memdesc:aa8a156d1dce89ff4ba435038ce909783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans the orthogonalization algorithm state, allocated in <code>mkernel_initialize_orthogonalization_mesh2d</code> (interactive mode)  <a href="namespacemeshkernelapi.html#aa8a156d1dce89ff4ba435038ce909783">More...</a><br /></td></tr>
<tr class="separator:aa8a156d1dce89ff4ba435038ce909783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1330d5672314ac364bd10964feabf87c"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a1330d5672314ac364bd10964feabf87c">mkernel_get_orthogonality_mesh2d</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryList)</td></tr>
<tr class="memdesc:a1330d5672314ac364bd10964feabf87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mesh orthogonality, expressed as the ratio between the edges and the segments connecting the face circumcenters.  <a href="namespacemeshkernelapi.html#a1330d5672314ac364bd10964feabf87c">More...</a><br /></td></tr>
<tr class="separator:a1330d5672314ac364bd10964feabf87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af795ef0aef37d30d210671012de70d13"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#af795ef0aef37d30d210671012de70d13">mkernel_get_smoothness_mesh2d</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryList)</td></tr>
<tr class="memdesc:af795ef0aef37d30d210671012de70d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the smoothness, expressed as the ratio between the values of two neighboring faces areas.  <a href="namespacemeshkernelapi.html#af795ef0aef37d30d210671012de70d13">More...</a><br /></td></tr>
<tr class="separator:af795ef0aef37d30d210671012de70d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d47258f24cf6884bb39bf648356e08"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a11d47258f24cf6884bb39bf648356e08">mkernel_get_splines</a> (const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListOut, int numberOfPointsBetweenNodes)</td></tr>
<tr class="memdesc:a11d47258f24cf6884bb39bf648356e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the computed spline points between two corner nodes.  <a href="namespacemeshkernelapi.html#a11d47258f24cf6884bb39bf648356e08">More...</a><br /></td></tr>
<tr class="separator:a11d47258f24cf6884bb39bf648356e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae616199ada08777b646c9c6131fcb668"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ae616199ada08777b646c9c6131fcb668">mkernel_get_closest_node_mesh2d</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;point, double searchRadius, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;node)</td></tr>
<tr class="memdesc:ae616199ada08777b646c9c6131fcb668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the closest mesh2d node coordinates to a point, searching within a radius.  <a href="namespacemeshkernelapi.html#ae616199ada08777b646c9c6131fcb668">More...</a><br /></td></tr>
<tr class="separator:ae616199ada08777b646c9c6131fcb668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646f50e11fbefa88192f6d8d2f8d17ee"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a646f50e11fbefa88192f6d8d2f8d17ee">mkernel_make_mesh_from_polygon_mesh2d</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygonPoints)</td></tr>
<tr class="memdesc:a646f50e11fbefa88192f6d8d2f8d17ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a triangular mesh2d grid within a polygon. The size of the triangles is determined from the length of the polygon edges.  <a href="namespacemeshkernelapi.html#a646f50e11fbefa88192f6d8d2f8d17ee">More...</a><br /></td></tr>
<tr class="separator:a646f50e11fbefa88192f6d8d2f8d17ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf2fc1671aeb174327ff7e69c8762aa"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aedf2fc1671aeb174327ff7e69c8762aa">mkernel_make_mesh_from_samples_mesh2d</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;samples)</td></tr>
<tr class="memdesc:aedf2fc1671aeb174327ff7e69c8762aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a triangular mesh from a set of samples, triangulating the sample points.  <a href="namespacemeshkernelapi.html#aedf2fc1671aeb174327ff7e69c8762aa">More...</a><br /></td></tr>
<tr class="separator:aedf2fc1671aeb174327ff7e69c8762aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d5b3eed8ca76a585dd6b03c66931d5"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a21d5b3eed8ca76a585dd6b03c66931d5">mkernel_get_mesh_boundaries_to_polygon_mesh2d</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;boundaryPolygons)</td></tr>
<tr class="memdesc:a21d5b3eed8ca76a585dd6b03c66931d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the boundaries of a mesh as a series of separated polygons. For example, if a mesh has an single inner hole, two polygons will be generated, one for the inner boundary and one for the outer boundary.  <a href="namespacemeshkernelapi.html#a21d5b3eed8ca76a585dd6b03c66931d5">More...</a><br /></td></tr>
<tr class="separator:a21d5b3eed8ca76a585dd6b03c66931d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ded9afe486c3a362c23b289c09c90e2"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a4ded9afe486c3a362c23b289c09c90e2">mkernel_count_mesh_boundaries_to_polygon_mesh2d</a> (int meshKernelId, int &amp;numberOfPolygonNodes)</td></tr>
<tr class="memdesc:a4ded9afe486c3a362c23b289c09c90e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of polygon nodes contained in the mesh boundary polygons computed in function <code>mkernel_get_mesh_boundaries_to_polygon_mesh2d</code>  <a href="namespacemeshkernelapi.html#a4ded9afe486c3a362c23b289c09c90e2">More...</a><br /></td></tr>
<tr class="separator:a4ded9afe486c3a362c23b289c09c90e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757cb24349b7a6c3df27e64a08ece938"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a757cb24349b7a6c3df27e64a08ece938">mkernel_refine_polygon</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn, int firstIndex, int secondIndex, double distance, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListOut)</td></tr>
<tr class="memdesc:a757cb24349b7a6c3df27e64a08ece938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the refined polygon.  <a href="namespacemeshkernelapi.html#a757cb24349b7a6c3df27e64a08ece938">More...</a><br /></td></tr>
<tr class="separator:a757cb24349b7a6c3df27e64a08ece938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10ab7a38f1585f66c670cc466921eb2"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ae10ab7a38f1585f66c670cc466921eb2">mkernel_count_refine_polygon</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn, int firstIndex, int secondIndex, double distance, int &amp;numberOfPolygonNodes)</td></tr>
<tr class="memdesc:ae10ab7a38f1585f66c670cc466921eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of nodes after polygon refinement.  <a href="namespacemeshkernelapi.html#ae10ab7a38f1585f66c670cc466921eb2">More...</a><br /></td></tr>
<tr class="separator:ae10ab7a38f1585f66c670cc466921eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2b569823ccc1b0297ab435126d3705"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#abd2b569823ccc1b0297ab435126d3705">mkernel_merge_nodes_mesh2d</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn)</td></tr>
<tr class="memdesc:abd2b569823ccc1b0297ab435126d3705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges nodes within a distance of 0.001 m, effectively removing small edges.  <a href="namespacemeshkernelapi.html#abd2b569823ccc1b0297ab435126d3705">More...</a><br /></td></tr>
<tr class="separator:abd2b569823ccc1b0297ab435126d3705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c32af26a383eef110451b6e178bef5"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ae5c32af26a383eef110451b6e178bef5">mkernel_merge_two_nodes_mesh2d</a> (int meshKernelId, int startNode, int endNode)</td></tr>
<tr class="memdesc:ae5c32af26a383eef110451b6e178bef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges node <code>startNode</code> to <code>endNode</code>.  <a href="namespacemeshkernelapi.html#ae5c32af26a383eef110451b6e178bef5">More...</a><br /></td></tr>
<tr class="separator:ae5c32af26a383eef110451b6e178bef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ee201dff9f75f261f1943f8b77a7e0"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ae4ee201dff9f75f261f1943f8b77a7e0">mkernel_get_nodes_in_polygons</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn, int inside, int **selectedNodes)</td></tr>
<tr class="memdesc:ae4ee201dff9f75f261f1943f8b77a7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the selected mesh node indices.  <a href="namespacemeshkernelapi.html#ae4ee201dff9f75f261f1943f8b77a7e0">More...</a><br /></td></tr>
<tr class="separator:ae4ee201dff9f75f261f1943f8b77a7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c314fd2768dfbd8398594b5ccf0dfb"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a91c314fd2768dfbd8398594b5ccf0dfb">mkernel_count_nodes_in_polygons</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn, int inside, int &amp;numberOfMeshNodes)</td></tr>
<tr class="memdesc:a91c314fd2768dfbd8398594b5ccf0dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of selected mesh node indices.  <a href="namespacemeshkernelapi.html#a91c314fd2768dfbd8398594b5ccf0dfb">More...</a><br /></td></tr>
<tr class="separator:a91c314fd2768dfbd8398594b5ccf0dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5bb8bc2c641b9cb32da76c64eb1a39"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a3d5bb8bc2c641b9cb32da76c64eb1a39">mkernel_insert_edge_mesh2d</a> (int meshKernelId, int startNode, int endNode, int &amp;newEdgeIndex)</td></tr>
<tr class="memdesc:a3d5bb8bc2c641b9cb32da76c64eb1a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new edge connecting <code>startNode</code> and <code>endNode</code>.  <a href="namespacemeshkernelapi.html#a3d5bb8bc2c641b9cb32da76c64eb1a39">More...</a><br /></td></tr>
<tr class="separator:a3d5bb8bc2c641b9cb32da76c64eb1a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fc17b27e8332eda1dedcaef9a49795"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a12fc17b27e8332eda1dedcaef9a49795">mkernel_insert_node_mesh2d</a> (int meshKernelId, double xCoordinate, double yCoordinate, int &amp;nodeIndex)</td></tr>
<tr class="memdesc:a12fc17b27e8332eda1dedcaef9a49795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new node.  <a href="namespacemeshkernelapi.html#a12fc17b27e8332eda1dedcaef9a49795">More...</a><br /></td></tr>
<tr class="separator:a12fc17b27e8332eda1dedcaef9a49795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b4a71938275c44d66b54273e9d4170"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a72b4a71938275c44d66b54273e9d4170">mkernel_delete_node_mesh2d</a> (int meshKernelId, int nodeIndex)</td></tr>
<tr class="memdesc:a72b4a71938275c44d66b54273e9d4170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a node with specified <code>nodeIndex</code>.  <a href="namespacemeshkernelapi.html#a72b4a71938275c44d66b54273e9d4170">More...</a><br /></td></tr>
<tr class="separator:a72b4a71938275c44d66b54273e9d4170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f4a5bc448a39e154e5a245c03163c0"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a74f4a5bc448a39e154e5a245c03163c0">mkernel_move_node_mesh2d</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn, int nodeIndex)</td></tr>
<tr class="memdesc:a74f4a5bc448a39e154e5a245c03163c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a selected node to a new position.  <a href="namespacemeshkernelapi.html#a74f4a5bc448a39e154e5a245c03163c0">More...</a><br /></td></tr>
<tr class="separator:a74f4a5bc448a39e154e5a245c03163c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aae7832215a5ac69116a2e3f9d3914d"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a8aae7832215a5ac69116a2e3f9d3914d">mkernel_delete_edge_mesh2d</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn)</td></tr>
<tr class="memdesc:a8aae7832215a5ac69116a2e3f9d3914d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the closest mesh edge within the search radius from the input point.  <a href="namespacemeshkernelapi.html#a8aae7832215a5ac69116a2e3f9d3914d">More...</a><br /></td></tr>
<tr class="separator:a8aae7832215a5ac69116a2e3f9d3914d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc1ac1d67caca215c5b1934c2f290be"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a1cc1ac1d67caca215c5b1934c2f290be">mkernel_find_edge_mesh2d</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn, int &amp;edgeIndex)</td></tr>
<tr class="memdesc:a1cc1ac1d67caca215c5b1934c2f290be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the closest mesh edge within the search radius from the input point.  <a href="namespacemeshkernelapi.html#a1cc1ac1d67caca215c5b1934c2f290be">More...</a><br /></td></tr>
<tr class="separator:a1cc1ac1d67caca215c5b1934c2f290be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7db1b1be2641f9ce05906fbf7276ef7"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ab7db1b1be2641f9ce05906fbf7276ef7">mkernel_get_offsetted_polygon</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn, bool innerPolygon, double distance, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListOut)</td></tr>
<tr class="memdesc:ab7db1b1be2641f9ce05906fbf7276ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offsets a polygon.  <a href="namespacemeshkernelapi.html#ab7db1b1be2641f9ce05906fbf7276ef7">More...</a><br /></td></tr>
<tr class="separator:ab7db1b1be2641f9ce05906fbf7276ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3da815b0276b2b7b11f37f724f802d0"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ab3da815b0276b2b7b11f37f724f802d0">mkernel_count_offsetted_polygon</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn, bool innerPolygon, double distance, int &amp;numberOfPolygonNodes)</td></tr>
<tr class="memdesc:ab3da815b0276b2b7b11f37f724f802d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of nodes of the offsetted polygon Count the number of nodes after polygon refinement.  <a href="namespacemeshkernelapi.html#ab3da815b0276b2b7b11f37f724f802d0">More...</a><br /></td></tr>
<tr class="separator:ab3da815b0276b2b7b11f37f724f802d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a33a09ed722a59da88e33801fadb0d"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a82a33a09ed722a59da88e33801fadb0d">mkernel_refine_based_on_samples_mesh2d</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryList, const <a class="el" href="structmeshkernelapi_1_1_interpolation_parameters.html">InterpolationParameters</a> &amp;interpolationParameters, const <a class="el" href="structmeshkernelapi_1_1_sample_refine_parameters.html">SampleRefineParameters</a> &amp;sampleRefineParameters)</td></tr>
<tr class="memdesc:a82a33a09ed722a59da88e33801fadb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a grid based on the samples contained in the geometry list.  <a href="namespacemeshkernelapi.html#a82a33a09ed722a59da88e33801fadb0d">More...</a><br /></td></tr>
<tr class="separator:a82a33a09ed722a59da88e33801fadb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945c7051955b5ba78dae524f7ae0c98f"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a945c7051955b5ba78dae524f7ae0c98f">mkernel_refine_based_on_polygon_mesh2d</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryList, const <a class="el" href="structmeshkernelapi_1_1_interpolation_parameters.html">InterpolationParameters</a> &amp;interpolationParameters)</td></tr>
<tr class="memdesc:a945c7051955b5ba78dae524f7ae0c98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a grid based on polygon.  <a href="namespacemeshkernelapi.html#a945c7051955b5ba78dae524f7ae0c98f">More...</a><br /></td></tr>
<tr class="separator:a945c7051955b5ba78dae524f7ae0c98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428a0010fe5397eda44db81e271464a8"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a428a0010fe5397eda44db81e271464a8">mkernel_get_node_index_mesh2d</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListIn, double searchRadius, int &amp;nodeIndex)</td></tr>
<tr class="memdesc:a428a0010fe5397eda44db81e271464a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the node index closest to the input point.  <a href="namespacemeshkernelapi.html#a428a0010fe5397eda44db81e271464a8">More...</a><br /></td></tr>
<tr class="separator:a428a0010fe5397eda44db81e271464a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe44f7e4d26d53b0a88a18e2099243d2"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#abe44f7e4d26d53b0a88a18e2099243d2">mkernel_get_points_in_polygon</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;inputPolygon, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;inputPoints, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;selectedPoints)</td></tr>
<tr class="memdesc:abe44f7e4d26d53b0a88a18e2099243d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects points in polygons.  <a href="namespacemeshkernelapi.html#abe44f7e4d26d53b0a88a18e2099243d2">More...</a><br /></td></tr>
<tr class="separator:abe44f7e4d26d53b0a88a18e2099243d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a88c8745472aeebb657219a050fb04c"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a8a88c8745472aeebb657219a050fb04c">mkernel_flip_edges_mesh2d</a> (int meshKernelId, int isTriangulationRequired, int projectToLandBoundaryOption)</td></tr>
<tr class="memdesc:a8a88c8745472aeebb657219a050fb04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the edges.  <a href="namespacemeshkernelapi.html#a8a88c8745472aeebb657219a050fb04c">More...</a><br /></td></tr>
<tr class="separator:a8a88c8745472aeebb657219a050fb04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40422236cefe92baf917ba09dc460ba7"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a40422236cefe92baf917ba09dc460ba7">mkernel_count_obtuse_triangles_mesh2d</a> (int meshKernelId, int &amp;numObtuseTriangles)</td></tr>
<tr class="memdesc:a40422236cefe92baf917ba09dc460ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of obtuse triangles (those having one edge longer than the sum of the other two)  <a href="namespacemeshkernelapi.html#a40422236cefe92baf917ba09dc460ba7">More...</a><br /></td></tr>
<tr class="separator:a40422236cefe92baf917ba09dc460ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95c8e131bd417a38b2c9d929273a89e"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ad95c8e131bd417a38b2c9d929273a89e">mkernel_get_obtuse_triangles_mass_centers_mesh2d</a> (int meshKernelId, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;result)</td></tr>
<tr class="memdesc:ad95c8e131bd417a38b2c9d929273a89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the obtuse triangle mass centers (those having one edge longer than the sum of the other two)  <a href="namespacemeshkernelapi.html#ad95c8e131bd417a38b2c9d929273a89e">More...</a><br /></td></tr>
<tr class="separator:ad95c8e131bd417a38b2c9d929273a89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972af7ec8554d0a7b6edcbbaa2c4fc51"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a972af7ec8554d0a7b6edcbbaa2c4fc51">mkernel_count_small_flow_edge_centers_mesh2d</a> (int meshKernelId, double smallFlowEdgesThreshold, int &amp;numSmallFlowEdges)</td></tr>
<tr class="memdesc:a972af7ec8554d0a7b6edcbbaa2c4fc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the small flow edges (flow edges are the edges connecting the face circumcenters)  <a href="namespacemeshkernelapi.html#a972af7ec8554d0a7b6edcbbaa2c4fc51">More...</a><br /></td></tr>
<tr class="separator:a972af7ec8554d0a7b6edcbbaa2c4fc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cb3e2822d6b08c349d3511ae25bfa7"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a70cb3e2822d6b08c349d3511ae25bfa7">mkernel_get_small_flow_edge_centers_mesh2d</a> (int meshKernelId, double smallFlowEdgesThreshold, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;result)</td></tr>
<tr class="memdesc:a70cb3e2822d6b08c349d3511ae25bfa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the small flow edges (flow edges are the edges connecting the face circumcenters)  <a href="namespacemeshkernelapi.html#a70cb3e2822d6b08c349d3511ae25bfa7">More...</a><br /></td></tr>
<tr class="separator:a70cb3e2822d6b08c349d3511ae25bfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5968dc8e0017feb6dfb0c1c491fa92e"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ae5968dc8e0017feb6dfb0c1c491fa92e">mkernel_delete_small_flow_edges_mesh2d</a> (int meshKernelId, double smallFlowEdgesThreshold, double minFractionalAreaTriangles)</td></tr>
<tr class="memdesc:ae5968dc8e0017feb6dfb0c1c491fa92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the small flow edges (flow edges are the edges connecting the face circumcenters)  <a href="namespacemeshkernelapi.html#ae5968dc8e0017feb6dfb0c1c491fa92e">More...</a><br /></td></tr>
<tr class="separator:ae5968dc8e0017feb6dfb0c1c491fa92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1b45637fb394fb6e27ac2312847916"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aea1b45637fb394fb6e27ac2312847916">mkernel_compute_single_contacts</a> (int meshKernelId, const int *oneDNodeMask, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygons)</td></tr>
<tr class="memdesc:aea1b45637fb394fb6e27ac2312847916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 1d-2d contacts, where every single 1d node is connected to one 2d face circumcenter (ggeo_make1D2Dinternalnetlinks_dll)  <a href="namespacemeshkernelapi.html#aea1b45637fb394fb6e27ac2312847916">More...</a><br /></td></tr>
<tr class="separator:aea1b45637fb394fb6e27ac2312847916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06b63ab7c87f5749712f13dd5bb633a"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ae06b63ab7c87f5749712f13dd5bb633a">mkernel_compute_multiple_contacts</a> (int meshKernelId, const int *oneDNodeMask)</td></tr>
<tr class="memdesc:ae06b63ab7c87f5749712f13dd5bb633a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 1d-2d contacts, where a single 1d node is connected to multiple 2d face circumcenters (ggeo_make1D2Dembeddedlinks_dll)  <a href="namespacemeshkernelapi.html#ae06b63ab7c87f5749712f13dd5bb633a">More...</a><br /></td></tr>
<tr class="separator:ae06b63ab7c87f5749712f13dd5bb633a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11d2f447998f79ad27d6d619c9744d2"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ad11d2f447998f79ad27d6d619c9744d2">mkernel_compute_with_polygons_contacts</a> (int meshKernelId, const int *oneDNodeMask, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygons)</td></tr>
<tr class="memdesc:ad11d2f447998f79ad27d6d619c9744d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 1d-2d contacts, where a 2d face per polygon is connected to the closest 1d node (ggeo_make1D2Droofgutterpipes_dll)  <a href="namespacemeshkernelapi.html#ad11d2f447998f79ad27d6d619c9744d2">More...</a><br /></td></tr>
<tr class="separator:ad11d2f447998f79ad27d6d619c9744d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b76fbe3acff07f8d887f0018a82d7cd"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a4b76fbe3acff07f8d887f0018a82d7cd">mkernel_compute_with_points_contacts</a> (int meshKernelId, const int *oneDNodeMask, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;points)</td></tr>
<tr class="memdesc:a4b76fbe3acff07f8d887f0018a82d7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 1d-2d contacts, where 1d nodes are connected to the 2d faces mass centers containing the input point (ggeo_make1D2Dstreetinletpipes_dll)  <a href="namespacemeshkernelapi.html#a4b76fbe3acff07f8d887f0018a82d7cd">More...</a><br /></td></tr>
<tr class="separator:a4b76fbe3acff07f8d887f0018a82d7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7e4b3097ead2e873b8dc441091bfe6"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aea7e4b3097ead2e873b8dc441091bfe6">mkernel_compute_boundary_contacts</a> (int meshKernelId, const int *oneDNodeMask, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygons, double searchRadius)</td></tr>
<tr class="memdesc:aea7e4b3097ead2e873b8dc441091bfe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 1d-2d contacts, where 1d nodes are connected to the closest 2d faces at the boundary (ggeo_make1D2DRiverLinks_dll)  <a href="namespacemeshkernelapi.html#aea7e4b3097ead2e873b8dc441091bfe6">More...</a><br /></td></tr>
<tr class="separator:aea7e4b3097ead2e873b8dc441091bfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe230fe37417df9e581d874206ed8246"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#abe230fe37417df9e581d874206ed8246">mkernel_refine_curvilinear</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListFirstPoint, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListSecondPoint, int refinement)</td></tr>
<tr class="memdesc:abe230fe37417df9e581d874206ed8246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Curvilinear grid refinement.  <a href="namespacemeshkernelapi.html#abe230fe37417df9e581d874206ed8246">More...</a><br /></td></tr>
<tr class="separator:abe230fe37417df9e581d874206ed8246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0c1ab1fc7664ab6b5fa28dffcdd127"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aaf0c1ab1fc7664ab6b5fa28dffcdd127">mkernel_derefine_curvilinear</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListFirstPoint, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListSecondPoint)</td></tr>
<tr class="memdesc:aaf0c1ab1fc7664ab6b5fa28dffcdd127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Curvilinear grid derefinement.  <a href="namespacemeshkernelapi.html#aaf0c1ab1fc7664ab6b5fa28dffcdd127">More...</a><br /></td></tr>
<tr class="separator:aaf0c1ab1fc7664ab6b5fa28dffcdd127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58af33cde930464cd397d2ec3cf20d97"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a58af33cde930464cd397d2ec3cf20d97">mkernel_compute_transfinite_from_splines_curvilinear</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;splines, const <a class="el" href="structmeshkernelapi_1_1_curvilinear_parameters.html">CurvilinearParameters</a> &amp;curvilinearParameters)</td></tr>
<tr class="memdesc:a58af33cde930464cd397d2ec3cf20d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates curvilinear grid from splines with transfinite interpolation.  <a href="namespacemeshkernelapi.html#a58af33cde930464cd397d2ec3cf20d97">More...</a><br /></td></tr>
<tr class="separator:a58af33cde930464cd397d2ec3cf20d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceda13a37ff36cf26761b04af131e307"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aceda13a37ff36cf26761b04af131e307">mkernel_compute_transfinite_from_polygon_curvilinear</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygons, int firstNode, int secondNode, int thirdNode, bool useFourthSide)</td></tr>
<tr class="memdesc:aceda13a37ff36cf26761b04af131e307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a curvilinear mesh in a polygon. 3 separate polygon nodes need to be selected.  <a href="namespacemeshkernelapi.html#aceda13a37ff36cf26761b04af131e307">More...</a><br /></td></tr>
<tr class="separator:aceda13a37ff36cf26761b04af131e307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131f052b78b4ea1e1810fafd63f53008"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a131f052b78b4ea1e1810fafd63f53008">mkernel_compute_transfinite_from_triangle_curvilinear</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;polygon, int firstNode, int secondNode, int thirdNode)</td></tr>
<tr class="memdesc:a131f052b78b4ea1e1810fafd63f53008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a curvilinear mesh in a triangle. 3 separate polygon nodes need to be selected.  <a href="namespacemeshkernelapi.html#a131f052b78b4ea1e1810fafd63f53008">More...</a><br /></td></tr>
<tr class="separator:a131f052b78b4ea1e1810fafd63f53008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04ccccc67c101768f8d94edf64bc8d3"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ab04ccccc67c101768f8d94edf64bc8d3">mkernel_compute_orthogonal_grid_from_splines_curvilinear</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryList, const <a class="el" href="structmeshkernelapi_1_1_curvilinear_parameters.html">CurvilinearParameters</a> &amp;curvilinearParameters, const <a class="el" href="structmeshkernelapi_1_1_splines_to_curvilinear_parameters.html">SplinesToCurvilinearParameters</a> &amp;splinesToCurvilinearParameters)</td></tr>
<tr class="memdesc:ab04ccccc67c101768f8d94edf64bc8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes curvilinear grid from splines with an advancing front.  <a href="namespacemeshkernelapi.html#ab04ccccc67c101768f8d94edf64bc8d3">More...</a><br /></td></tr>
<tr class="separator:ab04ccccc67c101768f8d94edf64bc8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4a73810405597f98bcd85bb7c44920"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a5c4a73810405597f98bcd85bb7c44920">mkernel_initialize_orthogonal_grid_from_splines_curvilinear</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryList, const <a class="el" href="structmeshkernelapi_1_1_curvilinear_parameters.html">CurvilinearParameters</a> &amp;curvilinearParameters, const <a class="el" href="structmeshkernelapi_1_1_splines_to_curvilinear_parameters.html">SplinesToCurvilinearParameters</a> &amp;splinesToCurvilinearParameters)</td></tr>
<tr class="memdesc:a5c4a73810405597f98bcd85bb7c44920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a curvilinear grid from splines with the advancing front method. Initialization step (interactive)  <a href="namespacemeshkernelapi.html#a5c4a73810405597f98bcd85bb7c44920">More...</a><br /></td></tr>
<tr class="separator:a5c4a73810405597f98bcd85bb7c44920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af935b4578e618c4958c65c1080f6177b"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#af935b4578e618c4958c65c1080f6177b">mkernel_iterate_orthogonal_grid_from_splines_curvilinear</a> (int meshKernelId, int layer)</td></tr>
<tr class="memdesc:af935b4578e618c4958c65c1080f6177b"><td class="mdescLeft">&#160;</td><td class="mdescRight">One advancement of the front in curvilinear grid from splines (interactive)  <a href="namespacemeshkernelapi.html#af935b4578e618c4958c65c1080f6177b">More...</a><br /></td></tr>
<tr class="separator:af935b4578e618c4958c65c1080f6177b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3b91945a43cd7e094a6dc454060ef9"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#acd3b91945a43cd7e094a6dc454060ef9">mkernel_refresh_orthogonal_grid_from_splines_curvilinear</a> (int meshKernelId)</td></tr>
<tr class="memdesc:acd3b91945a43cd7e094a6dc454060ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts curvilinear grid to mesh and refreshes the state (interactive)  <a href="namespacemeshkernelapi.html#acd3b91945a43cd7e094a6dc454060ef9">More...</a><br /></td></tr>
<tr class="separator:acd3b91945a43cd7e094a6dc454060ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6380e7361903fe8d21654c9f8646cf6"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aa6380e7361903fe8d21654c9f8646cf6">mkernel_delete_orthogonal_grid_from_splines_curvilinear</a> (int meshKernelId)</td></tr>
<tr class="memdesc:aa6380e7361903fe8d21654c9f8646cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes curvilinear grid from splines algorithm.  <a href="namespacemeshkernelapi.html#aa6380e7361903fe8d21654c9f8646cf6">More...</a><br /></td></tr>
<tr class="separator:aa6380e7361903fe8d21654c9f8646cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa668297f911b47f6a9b912a2e5845df6"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aa668297f911b47f6a9b912a2e5845df6">mkernel_make_uniform_curvilinear</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_make_mesh_parameters.html">MakeMeshParameters</a> &amp;makeGridParameters, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryList)</td></tr>
<tr class="memdesc:aa668297f911b47f6a9b912a2e5845df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a new mesh.  <a href="namespacemeshkernelapi.html#aa668297f911b47f6a9b912a2e5845df6">More...</a><br /></td></tr>
<tr class="separator:aa668297f911b47f6a9b912a2e5845df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99d8dc15755c886156010998b4eb56c"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#ae99d8dc15755c886156010998b4eb56c">mkernel_initialize_orthogonalize_curvilinear</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_orthogonalization_parameters.html">OrthogonalizationParameters</a> &amp;orthogonalizationParameters)</td></tr>
<tr class="memdesc:ae99d8dc15755c886156010998b4eb56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the orthogonal curvilinear algorithm.  <a href="namespacemeshkernelapi.html#ae99d8dc15755c886156010998b4eb56c">More...</a><br /></td></tr>
<tr class="separator:ae99d8dc15755c886156010998b4eb56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcc1a0d43d489ee04c365846e7e444f"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#affcc1a0d43d489ee04c365846e7e444f">mkernel_set_frozen_lines_orthogonalize_curvilinear</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListFirstPoint, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListSecondPoint)</td></tr>
<tr class="memdesc:affcc1a0d43d489ee04c365846e7e444f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Freezes a line in the curvilinear orthogonalization process.  <a href="namespacemeshkernelapi.html#affcc1a0d43d489ee04c365846e7e444f">More...</a><br /></td></tr>
<tr class="separator:affcc1a0d43d489ee04c365846e7e444f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1319599b45076d2da5bf60c1547890"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a0a1319599b45076d2da5bf60c1547890">mkernel_set_block_orthogonalize_curvilinear</a> (int meshKernelId, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListFirstPoint, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;geometryListSecondPoint)</td></tr>
<tr class="memdesc:a0a1319599b45076d2da5bf60c1547890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a block on the curvilinear grid where to perform orthogonalization.  <a href="namespacemeshkernelapi.html#a0a1319599b45076d2da5bf60c1547890">More...</a><br /></td></tr>
<tr class="separator:a0a1319599b45076d2da5bf60c1547890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217138528c1c4904f79aba9d5d2bbb9e"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a217138528c1c4904f79aba9d5d2bbb9e">mkernel_orthogonalize_curvilinear</a> (int meshKernelId)</td></tr>
<tr class="memdesc:a217138528c1c4904f79aba9d5d2bbb9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthogonalize a curvilinear grid.  <a href="namespacemeshkernelapi.html#a217138528c1c4904f79aba9d5d2bbb9e">More...</a><br /></td></tr>
<tr class="separator:a217138528c1c4904f79aba9d5d2bbb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a7dd6abd2396682c68d7993f6c0bf1"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a94a7dd6abd2396682c68d7993f6c0bf1">mkernel_finalize_orthogonalize_curvilinear</a> (int meshKernelId)</td></tr>
<tr class="memdesc:a94a7dd6abd2396682c68d7993f6c0bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the CurvilinearGridOrthogonalization instance in <a class="el" href="classmeshkernelapi_1_1_mesh_kernel_state.html" title="The class holding the state of the C API library.">MeshKernelState</a>.  <a href="namespacemeshkernelapi.html#a94a7dd6abd2396682c68d7993f6c0bf1">More...</a><br /></td></tr>
<tr class="separator:a94a7dd6abd2396682c68d7993f6c0bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8390b9bd3c103a76f17f29803d4b68ad"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a8390b9bd3c103a76f17f29803d4b68ad">mkernel_smoothing_curvilinear</a> (int meshKernelId, int smoothingIterations, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;lowerLeftCorner, const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;upperRightCorner)</td></tr>
<tr class="memdesc:a8390b9bd3c103a76f17f29803d4b68ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooths a curvilinear grid.  <a href="namespacemeshkernelapi.html#a8390b9bd3c103a76f17f29803d4b68ad">More...</a><br /></td></tr>
<tr class="separator:a8390b9bd3c103a76f17f29803d4b68ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb3e04db4d916e7e993554b9ec0d303"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aecb3e04db4d916e7e993554b9ec0d303">mkernel_smoothing_directional_curvilinear</a> (int meshKernelId, int smoothingIterations, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> const &amp;firstSegmentNode, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> const &amp;secondSegmentNode, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> const &amp;lowerLeftCornerSmoothingArea, <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> const &amp;upperRightCornerSmootingArea)</td></tr>
<tr class="memdesc:aecb3e04db4d916e7e993554b9ec0d303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooths a curvilinear grid along the direction specified by a segment.  <a href="namespacemeshkernelapi.html#aecb3e04db4d916e7e993554b9ec0d303">More...</a><br /></td></tr>
<tr class="separator:aecb3e04db4d916e7e993554b9ec0d303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8a7a9f99cd5feedadca9b03aae4e4d"><td class="memItemLeft" align="right" valign="top"><a id="a0c8a7a9f99cd5feedadca9b03aae4e4d"></a>
MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a0c8a7a9f99cd5feedadca9b03aae4e4d">mkernel_convert_curvilinear_to_mesh2d</a> (int meshKernelId)</td></tr>
<tr class="memdesc:a0c8a7a9f99cd5feedadca9b03aae4e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a curvilinear grid to an unstructured mesh. <br /></td></tr>
<tr class="separator:a0c8a7a9f99cd5feedadca9b03aae4e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa4028baafe51cdd5e87fe898b4a426"><td class="memItemLeft" align="right" valign="top">MKERNEL_API double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a0fa4028baafe51cdd5e87fe898b4a426">mkernel_get_separator</a> ()</td></tr>
<tr class="memdesc:a0fa4028baafe51cdd5e87fe898b4a426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the double value used in the back-end library as separator and missing value.  <a href="namespacemeshkernelapi.html#a0fa4028baafe51cdd5e87fe898b4a426">More...</a><br /></td></tr>
<tr class="separator:a0fa4028baafe51cdd5e87fe898b4a426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329b68c1ddf16b487d2954b65481e3c4"><td class="memItemLeft" align="right" valign="top">MKERNEL_API double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a329b68c1ddf16b487d2954b65481e3c4">mkernel_get_inner_outer_separator</a> ()</td></tr>
<tr class="memdesc:a329b68c1ddf16b487d2954b65481e3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the double value used to separate the inner part of a polygon from its outer part.  <a href="namespacemeshkernelapi.html#a329b68c1ddf16b487d2954b65481e3c4">More...</a><br /></td></tr>
<tr class="separator:a329b68c1ddf16b487d2954b65481e3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154b32f4b2c4d460047b477a46625334"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a154b32f4b2c4d460047b477a46625334">triangulation</a> (const <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh2d, const double **samplesXCoordinate, const double **samplesYCoordinate, const double **samplesValue, const int &amp;numSamples, const int &amp;locationType, const int &amp;spherical, const int &amp;sphericalAccurate, double **results)</td></tr>
<tr class="memdesc:a154b32f4b2c4d460047b477a46625334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangle interpolation (ec_module)  <a href="namespacemeshkernelapi.html#a154b32f4b2c4d460047b477a46625334">More...</a><br /></td></tr>
<tr class="separator:a154b32f4b2c4d460047b477a46625334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed93033a27b7ead585c3b6d73a749f74"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#aed93033a27b7ead585c3b6d73a749f74">averaging</a> (const <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;mesh2d, const int &amp;startIndex, const double **samplesXCoordinate, const double **samplesYCoordinate, const double **samplesValue, const int &amp;numSamples, double **results, const int &amp;locationType, const double &amp;Wu1Duni, const int &amp;averagingMethod, const int &amp;minNumberOfSamples, const double &amp;relativeSearchSize, const int &amp;spherical, const int &amp;sphericalAccurate)</td></tr>
<tr class="memdesc:aed93033a27b7ead585c3b6d73a749f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">AveragingInterpolation interpolation (ec_module)  <a href="namespacemeshkernelapi.html#aed93033a27b7ead585c3b6d73a749f74">More...</a><br /></td></tr>
<tr class="separator:aed93033a27b7ead585c3b6d73a749f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b809a55fd930f5c266f5d12fdfa816"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a57b809a55fd930f5c266f5d12fdfa816">mkernel_get_error</a> (const char *&amp;error_message)</td></tr>
<tr class="memdesc:a57b809a55fd930f5c266f5d12fdfa816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets pointer to error message.  <a href="namespacemeshkernelapi.html#a57b809a55fd930f5c266f5d12fdfa816">More...</a><br /></td></tr>
<tr class="separator:a57b809a55fd930f5c266f5d12fdfa816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60110d717bc03445222a06bc765ef4f4"><td class="memItemLeft" align="right" valign="top">MKERNEL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemeshkernelapi.html#a60110d717bc03445222a06bc765ef4f4">mkernel_get_geometry_error</a> (int &amp;invalidIndex, int &amp;type)</td></tr>
<tr class="memdesc:a60110d717bc03445222a06bc765ef4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index of the erroneous entity.  <a href="namespacemeshkernelapi.html#a60110d717bc03445222a06bc765ef4f4">More...</a><br /></td></tr>
<tr class="separator:a60110d717bc03445222a06bc765ef4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all structs and functions exposed at the API level. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aed93033a27b7ead585c3b6d73a749f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed93033a27b7ead585c3b6d73a749f74">&#9670;&nbsp;</a></span>averaging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::averaging </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh2d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double **&#160;</td>
          <td class="paramname"><em>samplesXCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double **&#160;</td>
          <td class="paramname"><em>samplesYCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double **&#160;</td>
          <td class="paramname"><em>samplesValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>numSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>locationType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>Wu1Duni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>averagingMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>minNumberOfSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>relativeSearchSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>spherical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>sphericalAccurate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AveragingInterpolation interpolation (ec_module) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh2d</td><td><a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startIndex</td><td><a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> data start index (not used) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samplesXCoordinate</td><td>The sample x-coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samplesYCoordinate</td><td>The sample y-coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samplesValue</td><td>The sample values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numSamples</td><td>The number of samples </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>The interpolation results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">locationType</td><td>The location type (see MeshLocations enum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Wu1Duni</td><td>A setting for 1d meshes (not used) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">averagingMethod</td><td>The averaging method (see Method enum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minNumberOfSamples</td><td>The minimum amount of samples (not used) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relativeSearchSize</td><td>The relative search size around the location (larger increases the number of samples considered) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spherical</td><td>Current projection (0 cartesian, 1 spherical) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphericalAccurate</td><td>Accurate spherical computations (0 default spherical, 1 spherical accurate) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 Successful) </dd></dl>

</div>
</div>
<a id="a6fb9ca3c9bf8888d566fa3564ee10557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb9ca3c9bf8888d566fa3564ee10557">&#9670;&nbsp;</a></span>mkernel_allocate_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_allocate_state </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isGeographic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>meshKernelId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new mesh state and returns the generated <code>meshKernelId</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">isGeographic</td><td>Cartesian (0) or spherical (1) mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aea7e4b3097ead2e873b8dc441091bfe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7e4b3097ead2e873b8dc441091bfe6">&#9670;&nbsp;</a></span>mkernel_compute_boundary_contacts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_compute_boundary_contacts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>oneDNodeMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>searchRadius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 1d-2d contacts, where 1d nodes are connected to the closest 2d faces at the boundary (ggeo_make1D2DRiverLinks_dll) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmeshkernel_1_1_contacts.html#a4ec01984b66446a3db7cd48de077e5df" title="Computes 1d-2d contacts, where 1d nodes are connected to the closest 2d faces at the boundary (ggeo_m...">meshkernel::Contacts::ComputeBoundaryContacts</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oneDNodeMask</td><td>The mask to apply to 1d nodes (1 = connect node, 0 = do not generate contacts) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The points selecting the faces to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">searchRadius</td><td>The radius used for searching neighboring faces, if equal to doubleMissingValue, the search radius will be calculated internally. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 Successful) </dd></dl>

</div>
</div>
<a id="aaf8e39e81f15084af773c0bae2bf350b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8e39e81f15084af773c0bae2bf350b">&#9670;&nbsp;</a></span>mkernel_compute_inner_ortogonalization_iteration_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_compute_inner_ortogonalization_iteration_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs inner orthogonalization iteration, by slowly moving the mesh nodes to new optimal positions (interactive mode). <code>mkernel_prepare_outer_iteration_orthogonalization_mesh2d</code> function must be called before. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ae06b63ab7c87f5749712f13dd5bb633a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06b63ab7c87f5749712f13dd5bb633a">&#9670;&nbsp;</a></span>mkernel_compute_multiple_contacts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_compute_multiple_contacts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>oneDNodeMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 1d-2d contacts, where a single 1d node is connected to multiple 2d face circumcenters (ggeo_make1D2Dembeddedlinks_dll) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmeshkernel_1_1_contacts.html#a7f91875d5a0da23ffbb679e428aa94a3" title="Computes 1d-2d contacts, where a single 1d node is connected to multiple 2d face circumcenters (ggeo_...">meshkernel::Contacts::ComputeMultipleContacts</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oneDNodeMask</td><td>The mask to apply to 1d nodes (1 = connect node, 0 = do not generate contacts) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 Successful) </dd></dl>

</div>
</div>
<a id="ab04ccccc67c101768f8d94edf64bc8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04ccccc67c101768f8d94edf64bc8d3">&#9670;&nbsp;</a></span>mkernel_compute_orthogonal_grid_from_splines_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_compute_orthogonal_grid_from_splines_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_curvilinear_parameters.html">CurvilinearParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>curvilinearParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_splines_to_curvilinear_parameters.html">SplinesToCurvilinearParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>splinesToCurvilinearParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes curvilinear grid from splines with an advancing front. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryList</td><td>The input splines corners </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">curvilinearParameters</td><td>The input parameters to generate the curvilinear grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splinesToCurvilinearParameters</td><td>The parameters of the advancing front algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ae17462ce61816890c3782834ba591468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17462ce61816890c3782834ba591468">&#9670;&nbsp;</a></span>mkernel_compute_orthogonalization_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_compute_orthogonalization_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>projectToLandBoundaryOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_orthogonalization_parameters.html">OrthogonalizationParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>orthogonalizationParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>landBoundaries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mesh2d orthogonalization. The function modifies the mesh for achieving orthogonality between the edges and the segments connecting the face circumcenters. The amount of orthogonality is traded against the mesh smoothing (in this case the equality of face areas). The parameter to regulate the amount of orthogonalization is contained in <a class="el" href="structmeshkernelapi_1_1_orthogonalization_parameters.html#a5ffb52364fd8c379dda2bb37c24200c4">meshkernelapi::OrthogonalizationParameters::OrthogonalizationToSmoothingFactor</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projectToLandBoundaryOption</td><td>The option to determine how to snap to land boundaries </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orthogonalizationParameters</td><td>The structure containing the orthogonalization parameters <a class="el" href="structmeshkernelapi_1_1_orthogonalization_parameters.html">meshkernelapi::OrthogonalizationParameters</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The polygon where to perform the orthogonalization </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landBoundaries</td><td>The land boundaries to account for in the orthogonalization process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aea1b45637fb394fb6e27ac2312847916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1b45637fb394fb6e27ac2312847916">&#9670;&nbsp;</a></span>mkernel_compute_single_contacts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_compute_single_contacts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>oneDNodeMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 1d-2d contacts, where every single 1d node is connected to one 2d face circumcenter (ggeo_make1D2Dinternalnetlinks_dll) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmeshkernel_1_1_contacts.html#a57476eb77e849bc15dd48f6ba2ad0622" title="Computes 1d-2d contacts, where every single 1d node is connected to one 2d face circumcenter (ggeo_ma...">meshkernel::Contacts::ComputeSingleContacts</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oneDNodeMask</td><td>The mask to apply to 1d nodes (1 = connect node, 0 = do not generate contacts) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The polygons selecting the area where the 1d-2d contacts will be generated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 Successful) </dd></dl>

</div>
</div>
<a id="aceda13a37ff36cf26761b04af131e307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceda13a37ff36cf26761b04af131e307">&#9670;&nbsp;</a></span>mkernel_compute_transfinite_from_polygon_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_compute_transfinite_from_polygon_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>firstNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>secondNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thirdNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFourthSide</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a curvilinear mesh in a polygon. 3 separate polygon nodes need to be selected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The input polygons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstNode</td><td>The first selected node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondNode</td><td>The second selected node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thirdNode</td><td>The third node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useFourthSide</td><td>Use (true/false) the fourth polygon side to compute the curvilinear grid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a58af33cde930464cd397d2ec3cf20d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58af33cde930464cd397d2ec3cf20d97">&#9670;&nbsp;</a></span>mkernel_compute_transfinite_from_splines_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_compute_transfinite_from_splines_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>splines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_curvilinear_parameters.html">CurvilinearParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>curvilinearParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates curvilinear grid from splines with transfinite interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splines</td><td>The splines </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">curvilinearParameters</td><td>The curvilinear parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a131f052b78b4ea1e1810fafd63f53008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131f052b78b4ea1e1810fafd63f53008">&#9670;&nbsp;</a></span>mkernel_compute_transfinite_from_triangle_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_compute_transfinite_from_triangle_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>firstNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>secondNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thirdNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a curvilinear mesh in a triangle. 3 separate polygon nodes need to be selected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The input polygons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstNode</td><td>The first selected node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondNode</td><td>The second selected node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thirdNode</td><td>The third node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a4b76fbe3acff07f8d887f0018a82d7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b76fbe3acff07f8d887f0018a82d7cd">&#9670;&nbsp;</a></span>mkernel_compute_with_points_contacts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_compute_with_points_contacts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>oneDNodeMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 1d-2d contacts, where 1d nodes are connected to the 2d faces mass centers containing the input point (ggeo_make1D2Dstreetinletpipes_dll) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmeshkernel_1_1_contacts.html#acf4f82c10642d3e8b2d9e8bab6b07006" title="Computes 1d-2d contacts, where 1d nodes are connected to the 2d faces mass centers containing the inp...">meshkernel::Contacts::ComputeContactsWithPoints</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oneDNodeMask</td><td>The mask to apply to 1d nodes (1 = connect node, 0 = do not generate contacts) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>The points selecting the faces to connect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 Successful) </dd></dl>

</div>
</div>
<a id="ad11d2f447998f79ad27d6d619c9744d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11d2f447998f79ad27d6d619c9744d2">&#9670;&nbsp;</a></span>mkernel_compute_with_polygons_contacts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_compute_with_polygons_contacts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>oneDNodeMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes 1d-2d contacts, where a 2d face per polygon is connected to the closest 1d node (ggeo_make1D2Droofgutterpipes_dll) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmeshkernel_1_1_contacts.html#a198d5ed49e69fcf8700ce9cf34b4f081" title="Computes 1d-2d contacts, where a 2d face per polygon is connected to the closest 1d node (ggeo_make1D...">meshkernel::Contacts::ComputeContactsWithPolygons</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oneDNodeMask</td><td>The mask to apply to 1d nodes (1 = connect node, 0 = do not generate contacts) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygons</td><td>The polygons to connect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 Successful) </dd></dl>

</div>
</div>
<a id="a02a2b0f3831d51c06e32e893e11ce56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a2b0f3831d51c06e32e893e11ce56e">&#9670;&nbsp;</a></span>mkernel_count_hanging_edges_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_count_hanging_edges_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of hanging edges in a mesh2d. An hanging edge is an edge where one of the two nodes is not connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numEdges</td><td>The number of hanging edges </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a4ded9afe486c3a362c23b289c09c90e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ded9afe486c3a362c23b289c09c90e2">&#9670;&nbsp;</a></span>mkernel_count_mesh_boundaries_to_polygon_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_count_mesh_boundaries_to_polygon_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numberOfPolygonNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of polygon nodes contained in the mesh boundary polygons computed in function <code>mkernel_get_mesh_boundaries_to_polygon_mesh2d</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numberOfPolygonNodes</td><td>The number of polygon nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a91c314fd2768dfbd8398594b5ccf0dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c314fd2768dfbd8398594b5ccf0dfb">&#9670;&nbsp;</a></span>mkernel_count_nodes_in_polygons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_count_nodes_in_polygons </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numberOfMeshNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of selected mesh node indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The input polygons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inside</td><td>Count nodes inside (1) or outside (0) the polygon </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numberOfMeshNodes</td><td>The number of selected nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a40422236cefe92baf917ba09dc460ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40422236cefe92baf917ba09dc460ba7">&#9670;&nbsp;</a></span>mkernel_count_obtuse_triangles_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_count_obtuse_triangles_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numObtuseTriangles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of obtuse triangles (those having one edge longer than the sum of the other two) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numObtuseTriangles</td><td>The number of obtuse triangles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab3da815b0276b2b7b11f37f724f802d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3da815b0276b2b7b11f37f724f802d0">&#9670;&nbsp;</a></span>mkernel_count_offsetted_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_count_offsetted_polygon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>innerPolygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numberOfPolygonNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of nodes of the offsetted polygon Count the number of nodes after polygon refinement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The polygon to be offsetted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">innerPolygon</td><td>Compute inner (true) or outer (false) polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>The offset distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numberOfPolygonNodes</td><td>The number of nodes of the generated polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ae10ab7a38f1585f66c670cc466921eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10ab7a38f1585f66c670cc466921eb2">&#9670;&nbsp;</a></span>mkernel_count_refine_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_count_refine_polygon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>secondIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numberOfPolygonNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of nodes after polygon refinement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The input polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIndex</td><td>The index of the first node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondIndex</td><td>The index of the second node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>The refinement distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numberOfPolygonNodes</td><td>The number of nodes after refinement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a972af7ec8554d0a7b6edcbbaa2c4fc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972af7ec8554d0a7b6edcbbaa2c4fc51">&#9670;&nbsp;</a></span>mkernel_count_small_flow_edge_centers_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_count_small_flow_edge_centers_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>smallFlowEdgesThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numSmallFlowEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the small flow edges (flow edges are the edges connecting the face circumcenters) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smallFlowEdgesThreshold</td><td>The configurable threshold for detecting the small flow edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numSmallFlowEdges</td><td>The number of the small flow edges </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a57d1b16ba8121e1f11b1692b755647c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d1b16ba8121e1f11b1692b755647c3">&#9670;&nbsp;</a></span>mkernel_deallocate_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_deallocate_state </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-allocate mesh state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a8aae7832215a5ac69116a2e3f9d3914d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aae7832215a5ac69116a2e3f9d3914d">&#9670;&nbsp;</a></span>mkernel_delete_edge_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_delete_edge_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the closest mesh edge within the search radius from the input point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The input point coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="af75ffce4b12d93ff0c4f28182725399b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75ffce4b12d93ff0c4f28182725399b">&#9670;&nbsp;</a></span>mkernel_delete_hanging_edges_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_delete_hanging_edges_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes all hanging edges. An hanging edge is an edge where one of the two nodes is not connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="accced3de4893e24a53cce7480acaf03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accced3de4893e24a53cce7480acaf03e">&#9670;&nbsp;</a></span>mkernel_delete_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_delete_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deletionOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invertDeletion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a mesh in a polygon using several options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>The polygon where to perform the operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deletionOption</td><td>The deletion option <a class="el" href="classmeshkernel_1_1_mesh2_d.html#a41e7c8bf5e92fec3f46ba18204e8cc6e">meshkernel::Mesh2D::DeleteMeshOptions</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">invertDeletion</td><td>Inverts the deletion of selected features </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a72b4a71938275c44d66b54273e9d4170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b4a71938275c44d66b54273e9d4170">&#9670;&nbsp;</a></span>mkernel_delete_node_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_delete_node_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a node with specified <code>nodeIndex</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeIndex</td><td>The nodeIndex to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aa6380e7361903fe8d21654c9f8646cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6380e7361903fe8d21654c9f8646cf6">&#9670;&nbsp;</a></span>mkernel_delete_orthogonal_grid_from_splines_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_delete_orthogonal_grid_from_splines_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes curvilinear grid from splines algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aa8a156d1dce89ff4ba435038ce909783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a156d1dce89ff4ba435038ce909783">&#9670;&nbsp;</a></span>mkernel_delete_orthogonalization_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_delete_orthogonalization_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleans the orthogonalization algorithm state, allocated in <code>mkernel_initialize_orthogonalization_mesh2d</code> (interactive mode) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ae5968dc8e0017feb6dfb0c1c491fa92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5968dc8e0017feb6dfb0c1c491fa92e">&#9670;&nbsp;</a></span>mkernel_delete_small_flow_edges_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_delete_small_flow_edges_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>smallFlowEdgesThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minFractionalAreaTriangles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the small flow edges (flow edges are the edges connecting the face circumcenters) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smallFlowEdgesThreshold</td><td>The configurable threshold for detecting the small flow edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minFractionalAreaTriangles</td><td>The ratio of the face area to the average area of neighboring non triangular faces </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 Successful) </dd></dl>

</div>
</div>
<a id="aaf0c1ab1fc7664ab6b5fa28dffcdd127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0c1ab1fc7664ab6b5fa28dffcdd127">&#9670;&nbsp;</a></span>mkernel_derefine_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_derefine_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListFirstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListSecondPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Curvilinear grid derefinement. </p>
<p><code>geometryListFirstPoint</code> and <code>geometryListSecondPoint</code> must lie on the same gridline </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshKernelId</td><td>The id of the mesh state. </td></tr>
    <tr><td class="paramname">geometryListFirstPoint</td><td>The geometry list containing the first node of the segment defining the derefinement zone. </td></tr>
    <tr><td class="paramname">geometryListSecondPoint</td><td>The geometry list containing the second node of the segment defining the derefinement zone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 Successful) </dd></dl>

</div>
</div>
<a id="a3cec4a22944557a5a49657fbf081c18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cec4a22944557a5a49657fbf081c18d">&#9670;&nbsp;</a></span>mkernel_finalize_inner_ortogonalization_iteration_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_finalize_inner_ortogonalization_iteration_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes the orthogonalization outer iteration, computing the new coefficients for grid adaption and the new face circumcenters (interactive mode). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a94a7dd6abd2396682c68d7993f6c0bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a7dd6abd2396682c68d7993f6c0bf1">&#9670;&nbsp;</a></span>mkernel_finalize_orthogonalize_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_finalize_orthogonalize_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the CurvilinearGridOrthogonalization instance in <a class="el" href="classmeshkernelapi_1_1_mesh_kernel_state.html" title="The class holding the state of the C API library.">MeshKernelState</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a1cc1ac1d67caca215c5b1934c2f290be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc1ac1d67caca215c5b1934c2f290be">&#9670;&nbsp;</a></span>mkernel_find_edge_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_find_edge_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>edgeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the closest mesh edge within the search radius from the input point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The input point coordinates </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edgeIndex</td><td>The edge index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a8a88c8745472aeebb657219a050fb04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a88c8745472aeebb657219a050fb04c">&#9670;&nbsp;</a></span>mkernel_flip_edges_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_flip_edges_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isTriangulationRequired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>projectToLandBoundaryOption</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flips the edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isTriangulationRequired</td><td>The option to triangulate also non triangular cells (if activated squares becomes triangles) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projectToLandBoundaryOption</td><td>The option to determine how to snap to land boundaries </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ae616199ada08777b646c9c6131fcb668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae616199ada08777b646c9c6131fcb668">&#9670;&nbsp;</a></span>mkernel_get_closest_node_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_closest_node_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>searchRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the closest mesh2d node coordinates to a point, searching within a radius. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>Id of the grid state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>The point coordinate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">searchRadius</td><td>The radii where to search for mesh nodes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>The found <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> node coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a77639a92507d619d56b96e5964ff992f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77639a92507d619d56b96e5964ff992f">&#9670;&nbsp;</a></span>mkernel_get_data_contacts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_data_contacts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_contacts.html">Contacts</a> &amp;&#160;</td>
          <td class="paramname"><em>contacts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the contacts indices (from index / to indices) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">contacts</td><td><a class="el" href="structmeshkernelapi_1_1_contacts.html" title="A struct used to describe contacts between a 1d and a 2d mesh.">Contacts</a> data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="af466d153595d03f337513cf3a5710eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af466d153595d03f337513cf3a5710eba">&#9670;&nbsp;</a></span>mkernel_get_data_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_data_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html">CurvilinearGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>curvilinearGrid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the curvilinear grid data as a <a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html" title="A struct used to describe the values of a curvilinear grid in a C-compatible manner.">CurvilinearGrid</a> struct (converted as set of edges and nodes) </p>
<p>This function ought to be called after <code>mkernel_get_curvilinear_dimension</code> has been called and the pointers have been set to correctly sized memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">curvilinearGrid</td><td>The structure containing the curvilinear grid arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="af75c66c025de2d0af52e3f0a429ae851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75c66c025de2d0af52e3f0a429ae851">&#9670;&nbsp;</a></span>mkernel_get_data_mesh1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_data_mesh1d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_mesh1_d.html">Mesh1D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh1d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a> dimensions data. </p>
<p>This function ought to be called after <code>mkernel_get_dimensions_mesh1d</code> has been called and the pointers have been set to correctly sized memory </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh1d</td><td>The structure containing the <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a> arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a0212fa98df8ef054e17ce4a4f2a01561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0212fa98df8ef054e17ce4a4f2a01561">&#9670;&nbsp;</a></span>mkernel_get_data_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_data_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh2d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> dimensions data. </p>
<p>This function ought to be called after <code>mkernel_get_dimensions_mesh2d</code> has been called and the pointers have been set to correctly sized memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh2d</td><td>The <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a97e855bbd0f383630b4ffd1a548a0def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e855bbd0f383630b4ffd1a548a0def">&#9670;&nbsp;</a></span>mkernel_get_dimensions_contacts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_dimensions_contacts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_contacts.html">Contacts</a> &amp;&#160;</td>
          <td class="paramname"><em>contacts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of contacts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">contacts</td><td><a class="el" href="structmeshkernelapi_1_1_contacts.html" title="A struct used to describe contacts between a 1d and a 2d mesh.">Contacts</a> data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a02ebd6b10e71b31df22ed390f53ce571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ebd6b10e71b31df22ed390f53ce571">&#9670;&nbsp;</a></span>mkernel_get_dimensions_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_dimensions_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html">CurvilinearGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>curvilinearGrid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the curvilinear grid dimensions as a <a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html" title="A struct used to describe the values of a curvilinear grid in a C-compatible manner.">CurvilinearGrid</a> struct (converted as set of edges and nodes) </p>
<p>The integer parameters of the <a class="el" href="structmeshkernelapi_1_1_curvilinear_grid.html" title="A struct used to describe the values of a curvilinear grid in a C-compatible manner.">CurvilinearGrid</a> struct are set to the corresponding dimensions The pointers are set to null, and must be set to correctly sized memory before passing the struct to <code>mkernel_get_data_curvilinear</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">curvilinearGrid</td><td>The structure containing the dimensions of the curvilinear grid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aa403ef1b510b3afe20b9849464fdcaaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa403ef1b510b3afe20b9849464fdcaaf">&#9670;&nbsp;</a></span>mkernel_get_dimensions_mesh1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_dimensions_mesh1d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_mesh1_d.html">Mesh1D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh1d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a> dimensions. </p>
<p>The integer parameters of the <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a> struct are set to the corresponding dimensions The pointers are set to null, and must be set to correctly sized memory before passing the struct to <code>mkernel_get_dimensions_mesh1d</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mesh1d</td><td>The structure containing the dimensions of the <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="acb327095fac9936a6787580cf25dcd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb327095fac9936a6787580cf25dcd21">&#9670;&nbsp;</a></span>mkernel_get_dimensions_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_dimensions_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh2d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> dimensions. </p>
<p>The integer parameters of the <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> struct are set to the corresponding dimensions The pointers are set to null, and must be set to correctly sized memory before passing the struct to <code>mkernel_get_data_mesh2d</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mesh2d</td><td>The <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a57b809a55fd930f5c266f5d12fdfa816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b809a55fd930f5c266f5d12fdfa816">&#9670;&nbsp;</a></span>mkernel_get_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_error </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>error_message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets pointer to error message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">error_message</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a60110d717bc03445222a06bc765ef4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60110d717bc03445222a06bc765ef4f4">&#9670;&nbsp;</a></span>mkernel_get_geometry_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_geometry_error </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>invalidIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the index of the erroneous entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">invalidIndex</td><td>The index of the erroneous entity </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>The entity type (node, edge or face, see MeshLocations) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a21aa8fc7522fbab81f7fd2deed07cb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21aa8fc7522fbab81f7fd2deed07cb45">&#9670;&nbsp;</a></span>mkernel_get_hanging_edges_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_hanging_edges_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the indices of hanging edges. An hanging edge is an edge where one of the two nodes is not connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">edges</td><td>Pointer to memory where the indices of the hanging edges will be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a329b68c1ddf16b487d2954b65481e3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329b68c1ddf16b487d2954b65481e3c4">&#9670;&nbsp;</a></span>mkernel_get_inner_outer_separator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API double meshkernelapi::mkernel_get_inner_outer_separator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the double value used to separate the inner part of a polygon from its outer part. </p>
<dl class="section return"><dt>Returns</dt><dd>The double missing value used in mesh kernel </dd></dl>

</div>
</div>
<a id="a21d5b3eed8ca76a585dd6b03c66931d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d5b3eed8ca76a585dd6b03c66931d5">&#9670;&nbsp;</a></span>mkernel_get_mesh_boundaries_to_polygon_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_mesh_boundaries_to_polygon_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>boundaryPolygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the boundaries of a mesh as a series of separated polygons. For example, if a mesh has an single inner hole, two polygons will be generated, one for the inner boundary and one for the outer boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">boundaryPolygons</td><td>The output network boundary polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a428a0010fe5397eda44db81e271464a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428a0010fe5397eda44db81e271464a8">&#9670;&nbsp;</a></span>mkernel_get_node_index_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_node_index_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>searchRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nodeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the node index closest to the input point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The input point from where starting the search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">searchRadius</td><td>The search radius to use for the search </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeIndex</td><td>The index of the found node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ae4ee201dff9f75f261f1943f8b77a7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ee201dff9f75f261f1943f8b77a7e0">&#9670;&nbsp;</a></span>mkernel_get_nodes_in_polygons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_nodes_in_polygons </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>selectedNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the selected mesh node indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The input polygons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inside</td><td>Count nodes indices inside (1) or outside (0) the polygon </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedNodes</td><td>The selected nodes indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ad95c8e131bd417a38b2c9d929273a89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95c8e131bd417a38b2c9d929273a89e">&#9670;&nbsp;</a></span>mkernel_get_obtuse_triangles_mass_centers_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_obtuse_triangles_mass_centers_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the obtuse triangle mass centers (those having one edge longer than the sum of the other two) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The obtuse triangles mass centers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 Successful) </dd></dl>

</div>
</div>
<a id="ab7db1b1be2641f9ce05906fbf7276ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7db1b1be2641f9ce05906fbf7276ef7">&#9670;&nbsp;</a></span>mkernel_get_offsetted_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_offsetted_polygon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>innerPolygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offsets a polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The polygon to be offsetted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">innerPolygon</td><td>Compute inner (true) or outer (false) polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>The offset distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geometryListOut</td><td>The offsetted polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a1330d5672314ac364bd10964feabf87c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1330d5672314ac364bd10964feabf87c">&#9670;&nbsp;</a></span>mkernel_get_orthogonality_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_orthogonality_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mesh orthogonality, expressed as the ratio between the edges and the segments connecting the face circumcenters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geometryList</td><td>The orthogonality values of each edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="abe44f7e4d26d53b0a88a18e2099243d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe44f7e4d26d53b0a88a18e2099243d2">&#9670;&nbsp;</a></span>mkernel_get_points_in_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_points_in_polygon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>inputPolygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>inputPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>selectedPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects points in polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputPolygon</td><td>The polygon(s) used for selection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputPoints</td><td>The points to select </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedPoints</td><td>The selected points in the zCoordinates field (0.0 not selected, 1.0 selected) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a0fa4028baafe51cdd5e87fe898b4a426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa4028baafe51cdd5e87fe898b4a426">&#9670;&nbsp;</a></span>mkernel_get_separator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API double meshkernelapi::mkernel_get_separator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the double value used in the back-end library as separator and missing value. </p>
<dl class="section return"><dt>Returns</dt><dd>The double missing value used in mesh kernel </dd></dl>

</div>
</div>
<a id="a70cb3e2822d6b08c349d3511ae25bfa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cb3e2822d6b08c349d3511ae25bfa7">&#9670;&nbsp;</a></span>mkernel_get_small_flow_edge_centers_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_small_flow_edge_centers_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>smallFlowEdgesThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the small flow edges (flow edges are the edges connecting the face circumcenters) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smallFlowEdgesThreshold</td><td>The configurable threshold for detecting the small flow edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The center points of the small flow edges </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 Successful) </dd></dl>

</div>
</div>
<a id="af795ef0aef37d30d210671012de70d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af795ef0aef37d30d210671012de70d13">&#9670;&nbsp;</a></span>mkernel_get_smoothness_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_smoothness_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the smoothness, expressed as the ratio between the values of two neighboring faces areas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geometryList</td><td>The smoothness values at each edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a11d47258f24cf6884bb39bf648356e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d47258f24cf6884bb39bf648356e08">&#9670;&nbsp;</a></span>mkernel_get_splines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_get_splines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberOfPointsBetweenNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the computed spline points between two corner nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The input corner nodes of the splines </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geometryListOut</td><td>The output spline </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numberOfPointsBetweenNodes</td><td>The number of spline points to generate between two corner nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a5c4a73810405597f98bcd85bb7c44920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4a73810405597f98bcd85bb7c44920">&#9670;&nbsp;</a></span>mkernel_initialize_orthogonal_grid_from_splines_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_initialize_orthogonal_grid_from_splines_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_curvilinear_parameters.html">CurvilinearParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>curvilinearParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_splines_to_curvilinear_parameters.html">SplinesToCurvilinearParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>splinesToCurvilinearParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a curvilinear grid from splines with the advancing front method. Initialization step (interactive) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryList</td><td>The input splines corners </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">curvilinearParameters</td><td>The input parameters to generate the curvilinear grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splinesToCurvilinearParameters</td><td>The parameters of the advancing front algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a1c5eb7f2190125044064fb6cd3495ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5eb7f2190125044064fb6cd3495ecd">&#9670;&nbsp;</a></span>mkernel_initialize_orthogonalization_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_initialize_orthogonalization_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>projectToLandBoundaryOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_orthogonalization_parameters.html">OrthogonalizationParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>orthogonalizationParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListPolygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListLandBoundaries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization of the <a class="el" href="classmeshkernel_1_1_orthogonalization_and_smoothing.html">meshkernel::OrthogonalizationAndSmoothing</a> algorithm. This is the first function to call when using orthogonalization in interactive mode (visualizing the grid while is orthogonalizing), in order to set the internal state of the algorithm reused during the iterations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projectToLandBoundaryOption</td><td>The option to determine how to snap to land boundaries </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orthogonalizationParameters</td><td>The structure containing the user defined orthogonalization parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListPolygon</td><td>The polygon where to perform the orthogonalization </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListLandBoundaries</td><td>The land boundaries to account for in the orthogonalization process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ae99d8dc15755c886156010998b4eb56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99d8dc15755c886156010998b4eb56c">&#9670;&nbsp;</a></span>mkernel_initialize_orthogonalize_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_initialize_orthogonalize_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_orthogonalization_parameters.html">OrthogonalizationParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>orthogonalizationParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the orthogonal curvilinear algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orthogonalizationParameters</td><td>The orthogonalization parameters to use in the algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a3d5bb8bc2c641b9cb32da76c64eb1a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5bb8bc2c641b9cb32da76c64eb1a39">&#9670;&nbsp;</a></span>mkernel_insert_edge_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_insert_edge_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>newEdgeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new edge connecting <code>startNode</code> and <code>endNode</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startNode</td><td>The index of the first node to connect </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endNode</td><td>The index of the second node to connect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newEdgeIndex</td><td>The index of the new edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a12fc17b27e8332eda1dedcaef9a49795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fc17b27e8332eda1dedcaef9a49795">&#9670;&nbsp;</a></span>mkernel_insert_node_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_insert_node_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nodeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCoordinate</td><td>X-coordinate of the new node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yCoordinate</td><td>Y-coordinate of the new node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeIndex</td><td>The index of the new mesh node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="af935b4578e618c4958c65c1080f6177b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af935b4578e618c4958c65c1080f6177b">&#9670;&nbsp;</a></span>mkernel_iterate_orthogonal_grid_from_splines_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_iterate_orthogonal_grid_from_splines_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>One advancement of the front in curvilinear grid from splines (interactive) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>The layer index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a646f50e11fbefa88192f6d8d2f8d17ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646f50e11fbefa88192f6d8d2f8d17ee">&#9670;&nbsp;</a></span>mkernel_make_mesh_from_polygon_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_make_mesh_from_polygon_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>polygonPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a triangular mesh2d grid within a polygon. The size of the triangles is determined from the length of the polygon edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygonPoints</td><td>The polygon where to triangulate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aedf2fc1671aeb174327ff7e69c8762aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf2fc1671aeb174327ff7e69c8762aa">&#9670;&nbsp;</a></span>mkernel_make_mesh_from_samples_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_make_mesh_from_samples_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a triangular mesh from a set of samples, triangulating the sample points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samples</td><td>The samples where to triangulate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aa668297f911b47f6a9b912a2e5845df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa668297f911b47f6a9b912a2e5845df6">&#9670;&nbsp;</a></span>mkernel_make_uniform_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_make_uniform_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_make_mesh_parameters.html">MakeMeshParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>makeGridParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a new mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">makeGridParameters</td><td>The structure containing the make grid parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryList</td><td>The polygon to account for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="abd2b569823ccc1b0297ab435126d3705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2b569823ccc1b0297ab435126d3705">&#9670;&nbsp;</a></span>mkernel_merge_nodes_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_merge_nodes_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges nodes within a distance of 0.001 m, effectively removing small edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The polygon where to perform the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ae5c32af26a383eef110451b6e178bef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c32af26a383eef110451b6e178bef5">&#9670;&nbsp;</a></span>mkernel_merge_two_nodes_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_merge_two_nodes_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges node <code>startNode</code> to <code>endNode</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startNode</td><td>The index of the first node to merge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endNode</td><td>The index of the second node to merge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a74f4a5bc448a39e154e5a245c03163c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f4a5bc448a39e154e5a245c03163c0">&#9670;&nbsp;</a></span>mkernel_move_node_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_move_node_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves a selected node to a new position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The new coordinate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeIndex</td><td>The node index (to be detailed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a217138528c1c4904f79aba9d5d2bbb9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217138528c1c4904f79aba9d5d2bbb9e">&#9670;&nbsp;</a></span>mkernel_orthogonalize_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_orthogonalize_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orthogonalize a curvilinear grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ad920018b836147d687c69e83a037ae69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad920018b836147d687c69e83a037ae69">&#9670;&nbsp;</a></span>mkernel_prepare_outer_iteration_orthogonalization_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_prepare_outer_iteration_orthogonalization_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares an outer orthogonalization iteration, computing the new orthogonalization and smoothing weights from the modified geometry (in interactive mode) <code>mkernel_initialize_orthogonalization_mesh2d</code> function must be called before. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a945c7051955b5ba78dae524f7ae0c98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945c7051955b5ba78dae524f7ae0c98f">&#9670;&nbsp;</a></span>mkernel_refine_based_on_polygon_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_refine_based_on_polygon_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_interpolation_parameters.html">InterpolationParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>interpolationParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines a grid based on polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryList</td><td>The closed polygon where to perform the refinement </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interpolationParameters</td><td>The interpolation parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a82a33a09ed722a59da88e33801fadb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a33a09ed722a59da88e33801fadb0d">&#9670;&nbsp;</a></span>mkernel_refine_based_on_samples_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_refine_based_on_samples_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_interpolation_parameters.html">InterpolationParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>interpolationParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_sample_refine_parameters.html">SampleRefineParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>sampleRefineParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines a grid based on the samples contained in the geometry list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryList</td><td>The sample set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interpolationParameters</td><td>The interpolation parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRefineParameters</td><td>The interpolation settings related to the samples </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="abe230fe37417df9e581d874206ed8246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe230fe37417df9e581d874206ed8246">&#9670;&nbsp;</a></span>mkernel_refine_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_refine_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListFirstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListSecondPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refinement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Curvilinear grid refinement. </p>
<p><code>geometryListFirstPoint</code> and <code>geometryListSecondPoint</code> must lie on the same gridline </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListFirstPoint</td><td>The geometry list containing the first node of the segment defining the refinement zone. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListSecondPoint</td><td>The geometry list containing the second node of the segment defining the refinement zone. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refinement</td><td>The number of refinement lines between <code>geometryListFirstPoint</code> and <code>geometryListSecondPoint</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 Successful) </dd></dl>

</div>
</div>
<a id="a757cb24349b7a6c3df27e64a08ece938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757cb24349b7a6c3df27e64a08ece938">&#9670;&nbsp;</a></span>mkernel_refine_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_refine_polygon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>secondIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the refined polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListIn</td><td>The input polygons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIndex</td><td>The index of the first node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondIndex</td><td>The index of the second node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>The refinement distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geometryListOut</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="acd3b91945a43cd7e094a6dc454060ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3b91945a43cd7e094a6dc454060ef9">&#9670;&nbsp;</a></span>mkernel_refresh_orthogonal_grid_from_splines_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_refresh_orthogonal_grid_from_splines_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts curvilinear grid to mesh and refreshes the state (interactive) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a0a1319599b45076d2da5bf60c1547890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1319599b45076d2da5bf60c1547890">&#9670;&nbsp;</a></span>mkernel_set_block_orthogonalize_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_set_block_orthogonalize_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListFirstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListSecondPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a block on the curvilinear grid where to perform orthogonalization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListFirstPoint</td><td>The geometry list containing the lower left corner of the block to orthogonalize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListSecondPoint</td><td>The geometry list containing the upper left corner of the block to orthogonalize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="affcc1a0d43d489ee04c365846e7e444f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcc1a0d43d489ee04c365846e7e444f">&#9670;&nbsp;</a></span>mkernel_set_frozen_lines_orthogonalize_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_set_frozen_lines_orthogonalize_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListFirstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>geometryListSecondPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Freezes a line in the curvilinear orthogonalization process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListFirstPoint</td><td>The geometry list containing the first point of the line to freeze </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometryListSecondPoint</td><td>The geometry list containing the second point of the line to freeze </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a4d17e2e5e58e7cee09cbd6bfcb5cd370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d17e2e5e58e7cee09cbd6bfcb5cd370">&#9670;&nbsp;</a></span>mkernel_set_mesh1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_set_mesh1d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html">Mesh1D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh1d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="classmeshkernel_1_1_mesh1_d.html" title="A class derived from Mesh, which describes 1d meshes.">meshkernel::Mesh1D</a> state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh1d</td><td>The <a class="el" href="structmeshkernelapi_1_1_mesh1_d.html" title="A struct used to describe the values of a mesh 1d in a C-compatible manner.">Mesh1D</a> data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="ac68f65ac929aef17ef7c08598ddfb3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68f65ac929aef17ef7c08598ddfb3ea">&#9670;&nbsp;</a></span>mkernel_set_mesh2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_set_mesh2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh2d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="classmeshkernel_1_1_mesh2_d.html" title="A class derived from Mesh, which describes unstructures 2d meshes.">meshkernel::Mesh2D</a> state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh2d</td><td>The <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a8390b9bd3c103a76f17f29803d4b68ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8390b9bd3c103a76f17f29803d4b68ad">&#9670;&nbsp;</a></span>mkernel_smoothing_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_smoothing_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smoothingIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>lowerLeftCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> &amp;&#160;</td>
          <td class="paramname"><em>upperRightCorner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooths a curvilinear grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smoothingIterations</td><td>The number of smoothing iterations to perform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lowerLeftCorner</td><td>The geometry list containing the lower left corner of the block to smooth </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upperRightCorner</td><td>The geometry list containing the upper right corner of the block to smooth </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="aecb3e04db4d916e7e993554b9ec0d303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb3e04db4d916e7e993554b9ec0d303">&#9670;&nbsp;</a></span>mkernel_smoothing_directional_curvilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::mkernel_smoothing_directional_curvilinear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshKernelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smoothingIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> const &amp;&#160;</td>
          <td class="paramname"><em>firstSegmentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> const &amp;&#160;</td>
          <td class="paramname"><em>secondSegmentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> const &amp;&#160;</td>
          <td class="paramname"><em>lowerLeftCornerSmoothingArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmeshkernelapi_1_1_geometry_list.html">GeometryList</a> const &amp;&#160;</td>
          <td class="paramname"><em>upperRightCornerSmootingArea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooths a curvilinear grid along the direction specified by a segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshKernelId</td><td>The id of the mesh state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smoothingIterations</td><td>The number of smoothing iterations to perform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstSegmentNode</td><td>The first point of the segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondSegmentNode</td><td>The second point of the segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lowerLeftCornerSmoothingArea</td><td>The geometry list containing the lower left corner of the smoothing area </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upperRightCornerSmootingArea</td><td>The geometry list containing the upper right corner of the smoothing area </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

</div>
</div>
<a id="a154b32f4b2c4d460047b477a46625334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154b32f4b2c4d460047b477a46625334">&#9670;&nbsp;</a></span>triangulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MKERNEL_API int meshkernelapi::triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html">Mesh2D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh2d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double **&#160;</td>
          <td class="paramname"><em>samplesXCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double **&#160;</td>
          <td class="paramname"><em>samplesYCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double **&#160;</td>
          <td class="paramname"><em>samplesValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>numSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>locationType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>spherical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>sphericalAccurate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangle interpolation (ec_module) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh2d</td><td>The <a class="el" href="structmeshkernelapi_1_1_mesh2_d.html" title="A struct used to describe the values of an unstructured, two-dimensional mesh in a C-compatible manne...">Mesh2D</a> data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samplesXCoordinate</td><td>The sample x-coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samplesYCoordinate</td><td>The sample y-coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samplesValue</td><td>The sample values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numSamples</td><td>The number of samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">locationType</td><td>The location type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spherical</td><td>Current projection (0 cartesian, 1 spherical) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sphericalAccurate</td><td>Accurate spherical projection (0 default spherical, 1 spherical accurate) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>The interpolation results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 Successful) </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
